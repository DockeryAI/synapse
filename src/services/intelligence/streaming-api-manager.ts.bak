/**
 * Streaming API Manager - EventEmitter-based Progressive Loading
 *
 * Each API updates independently as it completes.
 * No waiting for batches or waves.
 * Shows cached data immediately, then streams fresh data.
 */

import { EventEmitter } from 'events';
import { DeepContext } from '../../types/intelligence';
import { selectAPIsForIndustry } from './industry-api-selector.service';
import { apiRetryWrapper } from './api-retry-wrapper';
import { performanceOptimizer } from './performance-optimizer.service';
import { triggerSearchQueryGenerator, type TriggerSearchQueries } from './trigger-search-query-generator.service';
import { triggerSynthesisService, type RawDataSample, type BrandProfile } from '../triggers/trigger-synthesis.service';
import { earlyTriggerLoaderService, type EarlyTriggerEvent } from '../triggers/early-trigger-loader.service';
import {
  type BusinessProfileType,
  type GatedApiType,
  shouldRunApi,
  getApiPriorityOrder,
  getApiWeight,
  getEnabledApis,
} from '@/services/triggers';
import type { CompleteUVP } from '@/types/uvp-flow.types';

// API Event Types
export type ApiEventType =
  | 'youtube-trending'
  | 'youtube-comments'
  | 'youtube-engagement'
  | 'apify-website'
  | 'apify-maps'
  | 'apify-reviews'
  | 'apify-instagram'
  | 'apify-twitter-sentiment'
  | 'apify-quora-insights'
  | 'apify-linkedin-b2b'
  | 'apify-trustpilot-reviews'
  | 'apify-g2-reviews'
  | 'outscraper-business'
  | 'outscraper-reviews'
  | 'serper-search'
  | 'serper-quora'
  | 'serper-news'
  | 'semrush-domain'
  | 'semrush-keywords'
  | 'semrush-competitors'
  | 'semrush-backlinks'
  | 'news-breaking'
  | 'news-trending'
  | 'weather-conditions'
  | 'linkedin-company'
  | 'linkedin-network'
  | 'perplexity-research'
  | 'website-analysis'
  | 'keywords-intent'
  | 'keywords-validated'
  | 'competitor-voice'  // Competitor Voice of Customer data from Gaps tab
  // Multi-source trigger integration (Phase J)
  | 'hackernews-triggers'  // Tech community switching signals
  | 'news-event-triggers'  // Funding, acquisitions, leadership changes
  | 'reddit-conversations'  // UVP pain point community validation
  | 'linkedin-executive-signals'  // B2B executive/hiring signals
  // Synapse 2.0 - Hidden data sources
  | 'sec-edgar-intelligence'  // SEC filings - risk factors, executive priorities
  | 'buzzsumo-performance';  // Content performance + trend timing

export interface ApiUpdate {
  type: ApiEventType;
  data: any;
  timestamp: number;
  fromCache: boolean;
  error?: Error;
}

export interface ApiStatus {
  type: ApiEventType;
  status: 'idle' | 'loading' | 'success' | 'error';
  startTime?: number;
  endTime?: number;
  duration?: number;
  error?: Error;
}

class StreamingApiManager extends EventEmitter {
  private apiStatuses: Map<ApiEventType, ApiStatus> = new Map();
  private cache: Map<string, { data: any; timestamp: number }> = new Map();
  private CACHE_TTL = 60 * 60 * 1000; // 1 hour

  // PERMANENT FIX: Event batching to prevent 23+ separate re-renders
  // Research source: React 18 batching only works within same event loop tick
  // Async callbacks create new ticks, so we manually batch with a 200ms window
  private eventBuffer: Map<ApiEventType, ApiUpdate> = new Map();
  private batchFlushTimeout: ReturnType<typeof setTimeout> | null = null;
  private readonly BATCH_WINDOW_MS = 200; // Batch events within 200ms window

  // Profile-based query generation
  private currentSearchQueries: TriggerSearchQueries | null = null;
  private currentProfileType: BusinessProfileType = 'national-saas';
  private currentUVP: CompleteUVP | null = null;
  private currentBrandName: string = '';
  private currentIndustry: string = '';

  // Buffer for raw data samples (for LLM trigger synthesis)
  private rawDataBuffer: RawDataSample[] = [];

  // Guard against duplicate/concurrent loadAllApis calls
  private isLoadingApis = false;
  private currentLoadBrandId: string | null = null;
  private currentForceFresh = false; // Skip cached data sources when forcing fresh fetch

  // Early loading state
  private earlyLoadingStarted = false;
  private earlyLoadBrandId: string | null = null;

  // =========================================================================
  // PHASE 10: Trusted Source Domains - Reject hallucinated/fake sources
  // Only accept evidence from platforms with REAL user-generated content
  // =========================================================================
  private readonly TRUSTED_SOURCE_DOMAINS: Set<string> = new Set([
    // Tier 1 - Verified UGC Platforms (highest trust)
    'reddit.com',
    'g2.com',
    'trustpilot.com',
    'capterra.com',
    'gartner.com',
    'trustradius.com',
    'softwareadvice.com',
    'getapp.com',

    // Tier 2 - Professional/Social Platforms
    'linkedin.com',
    'quora.com',
    'youtube.com',
    'twitter.com',
    'x.com',
    'medium.com',
    'dev.to',
    'hackernews.com',
    'news.ycombinator.com',

    // Tier 3 - Industry Publications
    'forbes.com',
    'techcrunch.com',
    'venturebeat.com',
    'zdnet.com',
    'cio.com',
    'computerworld.com',
    'infoworld.com',
    'wired.com',
    'theverge.com',
    'arstechnica.com',
    'infotechlead.com',
    'insurancetimes.co.uk',
    'insurancejournal.com',
    'propertycasualty360.com',

    // Tier 4 - Research/Analyst Firms
    'forrester.com',
    'mckinsey.com',
    'hbr.org',
    'deloitte.com',
    'accenture.com',
    'pwc.com',
    'bain.com',
    'bcg.com',

    // Tier 5 - Industry-Specific (SaaS/Tech)
    'producthunt.com',
    'betalist.com',
    'saashub.com',
    'alternativeto.net',
    'slashdot.org',
    'stackoverflow.com',
    'stackexchange.com',

    // Tier 6 - Tech Community Forums
    'cursor.com',
    'tribe.ai',
    'community.openai.com',
    'discuss.huggingface.co',
    'discord.com',
    'slack.com',
    'discourse.org',

    // Tier 7 - AI/Tech News
    'theinformation.com',
    'semafor.com',
    'axios.com',
    'businessinsider.com',
    'insider.com',
    'cnbc.com',
    'bloomberg.com',
    'reuters.com',
    'wsj.com',
    'nytimes.com',
  ]);

  /**
   * Validate if a URL is a valid, real URL structure
   * CHANGED: No longer restricts to allowlist - accepts any valid URL
   * Only rejects obviously fake/malformed URLs
   */
  private isValidSourceDomain(url: string | undefined): boolean {
    if (!url) return false;

    try {
      const parsed = new URL(url);
      const hostname = parsed.hostname.toLowerCase();

      // Must have a valid protocol
      if (!['http:', 'https:'].includes(parsed.protocol)) {
        return false;
      }

      // Must have a real domain (not localhost, not IP only)
      if (hostname === 'localhost' || /^\d+\.\d+\.\d+\.\d+$/.test(hostname)) {
        return false;
      }

      // Must have at least one dot (real domain)
      if (!hostname.includes('.')) {
        return false;
      }

      // Reject obviously fake/placeholder domains AND known LLM hallucinations
      const fakeDomains = [
        // Placeholder/test domains
        'example.com', 'test.com', 'placeholder.com', 'fake.com',
        // Known LLM hallucinations - Perplexity sometimes invents these
        // NOTE: spear-tech.com is VALID - https://www.spear-tech.com/ensuring-compliance-with-technology-a-guide-for-insurers/
        'aiplatform-reviews.com', // Common hallucination pattern
        'tech-solution.com',
        'enterprise-ai.com',
        'ai-insights.com',
        'software-reviews.net',
        'chatbot-platform.com',
      ];
      if (fakeDomains.some(fake => hostname.includes(fake))) {
        console.log(`[StreamingAPI] ‚ö†Ô∏è Rejected fake/hallucinated domain: ${hostname}`);
        return false;
      }

      // Accept any other valid URL
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Get profile-specific source guidance for Perplexity queries
   * Tells Perplexity which platforms to prioritize based on business profile
   */
  private getPerplexitySourceGuidance(profileType: BusinessProfileType): string {
    // V6 profile types: local-b2b, local-b2c, regional-agency, regional-retail, national-saas, national-product
    switch (profileType) {
      case 'local-b2b':
        return 'Search Google Reviews, LinkedIn, industry forums, BBB. Focus on local B2B service providers.';
      case 'local-b2c':
        return 'Search Google Reviews, Yelp, Facebook, NextDoor, local community forums. Focus on consumer reviews.';
      case 'regional-agency':
        return 'Search Clutch, G2, LinkedIn, industry-specific forums, case study discussions. Focus on agency/consulting reviews.';
      case 'regional-retail':
        return 'Search Google Reviews, Yelp, Facebook, local news, community forums. Focus on retail consumer feedback.';
      case 'national-saas':
        return 'Search G2, Capterra, TrustRadius, Reddit (r/SaaS, r/startups), HackerNews, LinkedIn discussions. Focus on B2B software reviews.';
      case 'national-product':
        return 'Search Trustpilot, Amazon reviews, Reddit (product-specific subreddits), TikTok, YouTube reviews. Focus on consumer product feedback.';
      default:
        return 'Search G2, Reddit, Trustpilot for customer reviews and discussions.';
    }
  }

  /**
   * Extract product keywords from UVP for search query enhancement
   * Used to make Perplexity queries product-specific instead of generic
   *
   * FIXED: Now extracts actual product description, not just pattern matches
   */
  private extractProductKeywords(uvp: CompleteUVP | null): string[] {
    if (!uvp) return [];

    const keywords: string[] = [];

    // PRIORITY 1: Use the FULL uniqueSolution statement (most accurate product description)
    if (uvp.uniqueSolution?.statement) {
      const solution = uvp.uniqueSolution.statement.trim();
      // Take the first sentence or first 100 chars as the product description
      const firstSentence = solution.split(/[.!?]/)[0]?.trim();
      if (firstSentence && firstSentence.length > 10) {
        keywords.push(firstSentence);
      }
    }

    // PRIORITY 2: Extract specific product category terms
    const fullText = [
      uvp.uniqueSolution?.statement || '',
      uvp.keyBenefit?.statement || '',
      typeof uvp.whatYouDo === 'string' ? uvp.whatYouDo : (uvp.whatYouDo as any)?.statement || ''
    ].join(' ').toLowerCase();

    // High-value product category patterns (prioritized)
    const highValuePatterns = [
      /conversational\s*ai/gi,
      /chatbot/gi,
      /virtual\s*assistant/gi,
      /ai\s*agent/gi,
      /customer\s*service\s*automation/gi,
      /intelligent\s*automation/gi,
      /dialogue\s*management/gi,
      /natural\s*language/gi,
      /voice\s*assistant/gi,
      /ai\s*platform/gi,
    ];

    for (const pattern of highValuePatterns) {
      const matches = fullText.match(pattern);
      if (matches) {
        keywords.push(...matches.map(m => m.trim()));
      }
    }

    // If no specific patterns found, fall back to whatYouDo
    if (keywords.length === 0 && uvp.whatYouDo) {
      const whatYouDo = typeof uvp.whatYouDo === 'string'
        ? uvp.whatYouDo
        : (uvp.whatYouDo as any)?.statement || '';
      if (whatYouDo.length > 10) {
        keywords.push(whatYouDo.split(/[.!?]/)[0]?.trim() || '');
      }
    }

    // Dedupe and clean
    const unique = [...new Set(keywords.filter(k => k && k.length > 3))];

    console.log('[StreamingAPI] Extracted product keywords:', unique.slice(0, 3));
    return unique;
  }

  /**
   * PHASE M: Extract buyer role from target customer statement
   * Examples:
   * - "Insurance agency COO/executive seeking..." ‚Üí "COO"
   * - "Enterprise IT directors looking for..." ‚Üí "IT director"
   * - "SMB business owners evaluating..." ‚Üí "business owner"
   */
  private extractBuyerRole(targetCustomer: string): string {
    if (!targetCustomer) return 'buyer';

    const statement = targetCustomer.toLowerCase();

    // C-suite patterns
    const csuiteMatch = statement.match(/\b(coo|ceo|cto|cio|cfo|cmo|ciso)\b/i);
    if (csuiteMatch) return csuiteMatch[1].toUpperCase();

    // VP/Director patterns
    const vpMatch = statement.match(/\b(vp|vice president|director)\s+(?:of\s+)?(\w+)/i);
    if (vpMatch) return `${vpMatch[1]} ${vpMatch[2]}`;

    // Manager/Lead patterns
    const managerMatch = statement.match(/\b(manager|head|lead)\s+(?:of\s+)?(\w+)/i);
    if (managerMatch) return `${managerMatch[1]} ${managerMatch[2]}`;

    // Role patterns
    const rolePatterns = [
      /\b(executive|founder|owner|partner|decision maker)\b/i,
      /\b(it director|operations manager|facilities manager)\b/i,
      /\b(buyer|customer|user)\b/i,
    ];

    for (const pattern of rolePatterns) {
      const match = statement.match(pattern);
      if (match) return match[1];
    }

    return 'buyer'; // Fallback
  }

  /**
   * PHASE M: Extract buyer industry from target customer statement
   * Examples:
   * - "Insurance agency COO/executive..." ‚Üí "insurance"
   * - "Healthcare IT directors..." ‚Üí "healthcare"
   * - "SaaS startup founders..." ‚Üí "SaaS"
   */
  private extractBuyerIndustry(targetCustomer: string): string | null {
    if (!targetCustomer) return null;

    const statement = targetCustomer.toLowerCase();

    const industryPatterns: Array<{ pattern: RegExp; industry: string }> = [
      { pattern: /\b(insurance|insurtech)\b/i, industry: 'insurance' },
      { pattern: /\b(healthcare|health\s*tech|medical)\b/i, industry: 'healthcare' },
      { pattern: /\b(financial|fintech|banking|finance)\b/i, industry: 'financial services' },
      { pattern: /\b(retail|ecommerce|e-commerce)\b/i, industry: 'retail' },
      { pattern: /\b(saas|software|tech|technology)\b/i, industry: 'SaaS' },
      { pattern: /\b(manufacturing|industrial)\b/i, industry: 'manufacturing' },
      { pattern: /\b(legal|law\s*firm)\b/i, industry: 'legal' },
      { pattern: /\b(real\s*estate|property)\b/i, industry: 'real estate' },
      { pattern: /\b(education|edtech|university)\b/i, industry: 'education' },
      { pattern: /\b(hospitality|hotel|restaurant)\b/i, industry: 'hospitality' },
      { pattern: /\b(logistics|supply\s*chain|transportation)\b/i, industry: 'logistics' },
    ];

    for (const { pattern, industry } of industryPatterns) {
      if (pattern.test(statement)) {
        return industry;
      }
    }

    return null; // No specific industry found
  }

  /**
   * Extract product category/industry from UVP instead of using NAICS codes
   * This ensures we use "conversational AI" instead of "Software Publishers"
   */
  private extractProductCategoryFromUVP(uvp: CompleteUVP | null, fallbackIndustry: string): string {
    if (!uvp) return fallbackIndustry;

    // Build full text from UVP
    const uniqueSolution = uvp.uniqueSolution?.statement || '';
    const keyBenefit = uvp.keyBenefit?.statement || '';
    const whatYouDo = typeof uvp.whatYouDo === 'string'
      ? uvp.whatYouDo
      : (uvp.whatYouDo as any)?.statement || '';
    const targetCustomer = uvp.targetCustomer?.statement || '';

    const fullText = `${uniqueSolution} ${keyBenefit} ${whatYouDo} ${targetCustomer}`.toLowerCase();

    // High-value category patterns that should override NAICS codes
    // Ordered by specificity - more specific matches first
    const categoryPatterns: Array<{ pattern: RegExp; category: string }> = [
      // Tech/AI
      { pattern: /conversational\s*ai/i, category: 'conversational AI' },
      { pattern: /chatbot|chat\s*bot/i, category: 'chatbot' },
      { pattern: /ai\s*agent|intelligent\s*agent/i, category: 'AI agent' },
      { pattern: /virtual\s*assistant/i, category: 'virtual assistant' },
      { pattern: /customer\s*service\s*automation/i, category: 'customer service automation' },
      { pattern: /contact\s*center\s*automation/i, category: 'contact center automation' },
      { pattern: /self-?service\s*platform/i, category: 'self-service platform' },

      // Marketing/Agency
      { pattern: /marketing\s*automation/i, category: 'marketing automation' },
      { pattern: /digital\s*marketing/i, category: 'digital marketing' },
      { pattern: /seo\s*(agency|services)/i, category: 'SEO services' },
      { pattern: /content\s*marketing/i, category: 'content marketing' },

      // Financial/Insurance
      { pattern: /insurance\s*(platform|automation|ai)/i, category: 'insurance technology' },
      { pattern: /fintech/i, category: 'fintech' },
      { pattern: /financial\s*services/i, category: 'financial services' },
      { pattern: /accounting\s*(software|platform)/i, category: 'accounting software' },

      // Local Services
      { pattern: /hvac|heating.*cooling/i, category: 'HVAC services' },
      { pattern: /dental|dentist/i, category: 'dental practice' },
      { pattern: /salon|beauty/i, category: 'salon and beauty' },
      { pattern: /restaurant|food\s*service/i, category: 'restaurant' },
      { pattern: /fitness|gym/i, category: 'fitness' },

      // Enterprise/B2B
      { pattern: /enterprise\s*software/i, category: 'enterprise software' },
      { pattern: /saas\s*platform/i, category: 'SaaS platform' },
      { pattern: /crm/i, category: 'CRM' },
      { pattern: /erp/i, category: 'ERP' },

      // E-commerce/Retail
      { pattern: /ecommerce|e-commerce/i, category: 'e-commerce' },
      { pattern: /retail\s*(platform|software)/i, category: 'retail technology' },
    ];

    // Find the first matching category
    for (const { pattern, category } of categoryPatterns) {
      if (pattern.test(fullText)) {
        console.log(`[StreamingAPI] üéØ UVP-derived product category: "${category}" (not NAICS "${fallbackIndustry}")`);
        return category;
      }
    }

    // If no specific pattern found, try to extract from whatYouDo first sentence
    if (whatYouDo && whatYouDo.length > 10) {
      const firstSentence = whatYouDo.split(/[.!?]/)[0]?.trim();
      if (firstSentence && firstSentence.length > 10 && firstSentence.length < 100) {
        console.log(`[StreamingAPI] üéØ Using whatYouDo as category: "${firstSentence}"`);
        return firstSentence;
      }
    }

    // Fallback to NAICS but warn
    console.warn(`[StreamingAPI] ‚ö†Ô∏è No UVP category found, using NAICS: "${fallbackIndustry}"`);
    return fallbackIndustry;
  }

  constructor() {
    super();
    this.setMaxListeners(50); // Support many components listening

    // Wire up early trigger loader for Phase 8.7
    this.setupEarlyLoadingListener();
  }

  /**
   * Set up listener for early trigger loading events
   * Starts loading as soon as Target Customer section is populated
   */
  private setupEarlyLoadingListener(): void {
    earlyTriggerLoaderService.on('queries-ready', (event: EarlyTriggerEvent) => {
      console.log('[StreamingAPI] üöÄ Early trigger queries ready - starting early loading');

      const { queries, profileType, brandId } = event.data;

      if (!brandId) {
        console.warn('[StreamingAPI] Early loading skipped - no brandId');
        return;
      }

      // Prevent duplicate early loading for same brand
      if (this.earlyLoadingStarted && this.earlyLoadBrandId === brandId) {
        console.log('[StreamingAPI] Early loading already started for this brand');
        return;
      }

      this.earlyLoadingStarted = true;
      this.earlyLoadBrandId = brandId;

      // Store profile type and queries for later use
      this.currentProfileType = profileType;

      // Mark loading as started in the early loader
      earlyTriggerLoaderService.markLoadingStarted();

      // Start lightweight early API calls (fast sources only)
      this.startEarlyApiLoading(brandId, profileType, queries);
    });

    // Reset early loading state when full UVP is ready
    earlyTriggerLoaderService.on('refinement-available', (event: EarlyTriggerEvent) => {
      if (event.data.isFinal) {
        console.log('[StreamingAPI] Full UVP ready - early loading complete');
        // Queries will be regenerated with full data in loadAllApis
      }
    });
  }

  /**
   * Start early API loading with profile-specific fast sources
   * Only loads quick, cache-friendly APIs to avoid blocking
   */
  private async startEarlyApiLoading(
    brandId: string,
    profileType: BusinessProfileType,
    queries: any
  ): Promise<void> {
    console.log('[StreamingAPI] Starting early loading for profile:', profileType);

    // For now, emit an event to notify that early loading has started
    // The full API loading will happen when loadAllApis is called
    this.emit('early-loading-started', {
      brandId,
      profileType,
      queriesReady: true,
      timestamp: Date.now()
    });

    // Start Perplexity research early (fast and high-value)
    // This is the most valuable early API call
    try {
      const { perplexityAPI } = await import('../uvp-wizard/perplexity-api');

      // Use fear queries for early research (from TriggerSearchQueries)
      const searchTerms = queries.fearQueries?.slice(0, 3) || [queries.targetCustomer, `${profileType} buyer triggers`];

      console.log('[StreamingAPI] Early Perplexity query:', searchTerms[0]);

      const perplexityData = await perplexityAPI.findPainPointConversations(
        searchTerms,
        queries.industry || 'technology'
      );

      if (perplexityData) {
        this.emitUpdate('perplexity-research', perplexityData, false);
        this.updateStatus('perplexity-research', 'success');
        console.log('[StreamingAPI] ‚úÖ Early Perplexity research complete');
      }
    } catch (error) {
      console.warn('[StreamingAPI] Early Perplexity failed (non-blocking):', error);
    }
  }

  /**
   * Reset early loading state (called when brand changes)
   */
  resetEarlyLoading(): void {
    this.earlyLoadingStarted = false;
    this.earlyLoadBrandId = null;
  }

  /**
   * Detect profile type from brand data (fallback when not provided)
   */
  private detectProfileFromBrand(brand: any): BusinessProfileType {
    const industry = (brand.industry || '').toLowerCase();
    const targetCustomers = (brand.targetCustomers || '').toLowerCase();

    // SaaS indicators
    if (industry.includes('software') || industry.includes('saas') ||
        industry.includes('platform') || industry.includes('ai') ||
        industry.includes('technology') || industry.includes('tech')) {
      // V6: No global-saas type in V6, use national-saas
      return 'national-saas';
    }

    // Agency indicators
    if (industry.includes('marketing') || industry.includes('consulting') ||
        industry.includes('agency') || industry.includes('accounting')) {
      return 'regional-agency';
    }

    // Local B2B indicators
    if (industry.includes('hvac') || industry.includes('plumbing') ||
        industry.includes('it services') || industry.includes('commercial')) {
      return 'local-b2b';
    }

    // Local B2C indicators
    if (industry.includes('dental') || industry.includes('salon') ||
        industry.includes('restaurant') || industry.includes('spa')) {
      return 'local-b2c';
    }

    // Product indicators
    if (industry.includes('retail') || industry.includes('product') ||
        industry.includes('manufacturing') || industry.includes('consumer')) {
      return 'national-product';
    }

    // Default to SaaS B2B for tech companies
    return 'national-saas';
  }

  /**
   * Get API gating configuration based on profile type
   * Used for TRIGGERS - general data collection
   *
   * PHASE B INTEGRATION: Now delegates to profile-detection.service.ts for
   * comprehensive API gating with 20+ API types and priority ordering.
   *
   * CRITICAL: YouTube is ONLY useful for B2C profiles where video content matters.
   * For B2B (especially SaaS), YouTube searches brand name and returns marketing videos,
   * NOT customer voice data. Disable YouTube for B2B profiles to reduce noise.
   */
  private getAPIGatingForProfile(profileType: BusinessProfileType): {
    useWeather: boolean;
    useLinkedIn: boolean;
    useG2: boolean;
    useLocalReviews: boolean;
    useTrustpilot: boolean;
    useYouTube: boolean;
    useReddit: boolean;
    // Extended Phase B fields
    useHackerNews: boolean;
    useCapterra: boolean;
    useTikTok: boolean;
    useAmazonReviews: boolean;
    useClutch: boolean;
    // Phase B functions for advanced gating
    enabledApis: GatedApiType[];
    priorityOrder: GatedApiType[];
    shouldRunApi: (api: GatedApiType) => boolean;
    getWeight: (api: GatedApiType) => number;
  } {
    // Use Phase B functions from profile-detection.service.ts
    const enabledApis = getEnabledApis(profileType);
    const priorityOrder = getApiPriorityOrder(profileType);

    // Log Phase B gating for debugging
    console.log(`[StreamingAPI] Phase B API Gating for ${profileType}:`, {
      enabled: enabledApis.slice(0, 5),
      priorityOrder: priorityOrder.slice(0, 5),
    });

    // Determine weather usage (local businesses benefit from weather-based triggers)
    const useWeather = profileType.includes('local');

    return {
      // Legacy boolean flags (for backward compatibility)
      useWeather,
      useLinkedIn: shouldRunApi(profileType, 'linkedin'),
      useG2: shouldRunApi(profileType, 'g2'),
      useLocalReviews: shouldRunApi(profileType, 'google-reviews') || shouldRunApi(profileType, 'yelp'),
      useTrustpilot: shouldRunApi(profileType, 'trustpilot'),
      useYouTube: shouldRunApi(profileType, 'youtube'),
      useReddit: shouldRunApi(profileType, 'reddit'),
      // Extended Phase B flags
      useHackerNews: shouldRunApi(profileType, 'hackernews'),
      useCapterra: shouldRunApi(profileType, 'capterra'),
      useTikTok: shouldRunApi(profileType, 'tiktok'),
      useAmazonReviews: shouldRunApi(profileType, 'amazon-reviews'),
      useClutch: shouldRunApi(profileType, 'clutch'),
      // Phase B functions for advanced use
      enabledApis,
      priorityOrder,
      shouldRunApi: (api: GatedApiType) => shouldRunApi(profileType, api),
      getWeight: (api: GatedApiType) => getApiWeight(profileType, api),
    };
  }

  /**
   * Get PROOF-specific API gating configuration
   * Different from trigger gating - focuses on credibility sources
   *
   * Proof API sources by profile:
   * - Local B2B: Google Reviews, Website (testimonials), BBB, LinkedIn
   * - Local B2C: Google Reviews, Yelp, Website, Healthgrades, Facebook
   * - Regional Agency: Clutch, Google Reviews, Website, LinkedIn, G2
   * - Regional Retail: Google Reviews, Website, Local awards, Facebook
   * - National SaaS: G2, Capterra, Website, TrustRadius, LinkedIn
   * - National Product: Trustpilot, Website, Amazon (future), Social
   */
  getProofAPIGatingForProfile(profileType: BusinessProfileType): {
    useGoogleReviews: boolean;
    useG2Reviews: boolean;
    useTrustpilot: boolean;
    useYelp: boolean;
    useLinkedIn: boolean;
    useWebsiteTestimonials: boolean;
    useCapterra: boolean;
    useTrustRadius: boolean;
    useClutch: boolean;
    useBBB: boolean;
    useHealthgrades: boolean;
    useFacebook: boolean;
    priority: ApiEventType[];  // Ordered list of which APIs to prioritize
  } {
    switch (profileType) {
      case 'local-b2b':
        // Commercial HVAC, IT services, etc.
        return {
          useGoogleReviews: true,
          useG2Reviews: false,
          useTrustpilot: false,
          useYelp: false,       // Skip consumer Yelp
          useLinkedIn: true,
          useWebsiteTestimonials: true,
          useCapterra: false,
          useTrustRadius: false,
          useClutch: false,
          useBBB: true,
          useHealthgrades: false,
          useFacebook: false,
          priority: ['outscraper-reviews', 'website-analysis', 'apify-linkedin-b2b'],
        };

      case 'local-b2c':
        // Dental, salon, restaurant, etc.
        return {
          useGoogleReviews: true,
          useG2Reviews: false,
          useTrustpilot: true,
          useYelp: true,        // Yelp important for local B2C
          useLinkedIn: false,
          useWebsiteTestimonials: true,
          useCapterra: false,
          useTrustRadius: false,
          useClutch: false,
          useBBB: true,
          useHealthgrades: true, // For healthcare services
          useFacebook: true,
          priority: ['outscraper-reviews', 'website-analysis', 'apify-trustpilot-reviews'],
        };

      case 'regional-agency':
        // Marketing, accounting, consulting
        return {
          useGoogleReviews: true,
          useG2Reviews: true,
          useTrustpilot: true,
          useYelp: false,
          useLinkedIn: true,
          useWebsiteTestimonials: true,
          useCapterra: false,
          useTrustRadius: false,
          useClutch: true,      // Clutch important for agencies
          useBBB: false,
          useHealthgrades: false,
          useFacebook: false,
          priority: ['apify-g2-reviews', 'outscraper-reviews', 'website-analysis', 'apify-linkedin-b2b'],
        };

      case 'regional-retail':
        // Multi-location retail, franchise
        return {
          useGoogleReviews: true,
          useG2Reviews: false,
          useTrustpilot: true,
          useYelp: true,
          useLinkedIn: false,
          useWebsiteTestimonials: true,
          useCapterra: false,
          useTrustRadius: false,
          useClutch: false,
          useBBB: true,
          useHealthgrades: false,
          useFacebook: true,
          priority: ['outscraper-reviews', 'website-analysis', 'apify-trustpilot-reviews'],
        };

      case 'national-saas':
        // SaaS companies
        return {
          useGoogleReviews: false,  // Skip local reviews
          useG2Reviews: true,       // Primary source
          useTrustpilot: true,
          useYelp: false,
          useLinkedIn: true,
          useWebsiteTestimonials: true,
          useCapterra: true,        // Important for SaaS
          useTrustRadius: true,     // Enterprise reviews
          useClutch: false,
          useBBB: false,
          useHealthgrades: false,
          useFacebook: false,
          priority: ['apify-g2-reviews', 'website-analysis', 'apify-trustpilot-reviews', 'apify-linkedin-b2b'],
        };

      case 'national-product':
        // Consumer brands, manufacturers
        return {
          useGoogleReviews: false,
          useG2Reviews: false,
          useTrustpilot: true,      // Primary consumer review source
          useYelp: false,
          useLinkedIn: false,
          useWebsiteTestimonials: true,
          useCapterra: false,
          useTrustRadius: false,
          useClutch: false,
          useBBB: false,
          useHealthgrades: false,
          useFacebook: true,        // Social proof
          priority: ['apify-trustpilot-reviews', 'website-analysis'],
        };

      default:
        // Default to SaaS-like gating
        return {
          useGoogleReviews: true,
          useG2Reviews: true,
          useTrustpilot: true,
          useYelp: false,
          useLinkedIn: true,
          useWebsiteTestimonials: true,
          useCapterra: false,
          useTrustRadius: false,
          useClutch: false,
          useBBB: false,
          useHealthgrades: false,
          useFacebook: false,
          priority: ['outscraper-reviews', 'apify-g2-reviews', 'website-analysis'],
        };
    }
  }

  /**
   * Get cached data for immediate display
   */
  getCachedData(brandId: string): Partial<DeepContext> {
    const cacheKey = `deep-context-${brandId}`;
    const cached = this.cache.get(cacheKey);

    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      console.log('[StreamingAPI] Returning cached data for immediate display');
      return cached.data;
    }

    return {};
  }

  /**
   * Clear all cached data - use when data is stale/garbage
   * Also resets loading guards to allow fresh API calls
   */
  clearCache(brandId?: string): void {
    // Reset loading guards so user can force a fresh load
    this.isLoadingApis = false;
    this.currentLoadBrandId = null;

    if (brandId) {
      const cacheKey = `deep-context-${brandId}`;
      this.cache.delete(cacheKey);
      console.log(`[StreamingAPI] Cleared cache for brand: ${brandId}`);
    } else {
      this.cache.clear();
      console.log('[StreamingAPI] Cleared ALL cached data');
    }
  }

  /**
   * Clear Supabase cached trigger data - async method for forceFresh mode
   * Deletes stale data from brand_competitor_voice table
   */
  private async clearSupabaseTriggerCaches(brandId: string): Promise<void> {
    try {
      const { supabase } = await import('@/lib/supabase');

      // Delete old competitor voice data to force fresh fetch
      const { error } = await supabase
        .from('brand_competitor_voice')
        .delete()
        .eq('brand_id', brandId);

      if (error && !error.message?.includes('relation')) {
        console.warn('[StreamingAPI] Failed to clear brand_competitor_voice:', error);
      } else {
        console.log('[StreamingAPI] üóëÔ∏è Cleared Supabase brand_competitor_voice cache for brand:', brandId);
      }
    } catch (e) {
      console.warn('[StreamingAPI] Failed to clear Supabase caches:', e);
    }
  }

  /**
   * Clear ALL caches including localStorage - use for forceFresh mode
   * This ensures APIs actually fire instead of returning cached data
   */
  private clearAllCaches(brandId: string): void {
    // Clear in-memory cache
    this.clearCache(brandId);

    // Clear localStorage caches that might prevent API calls
    try {
      // Clear deepContext cache
      localStorage.removeItem(`deepContext_${brandId}`);
      localStorage.removeItem(`deep-context-${brandId}`);

      // Clear triggers cache - ALL versions
      localStorage.removeItem('triggersDevPage_deepContext_v1');
      localStorage.removeItem('triggersDevPage_triggers_v1');
      localStorage.removeItem('triggersDevPage_deepContext_v2');
      localStorage.removeItem('triggersDevPage_triggers_v2');
      localStorage.removeItem('triggersDevPage_deepContext_v3');
      localStorage.removeItem('triggersDevPage_triggers_v3');
      localStorage.removeItem('triggersDevPage_brand_v3');
      localStorage.removeItem('triggersDevPage_apiDisabled_v3');

      // Clear raw data buffer - ALL versions
      localStorage.removeItem('triggersDevPage_rawDataBuffer_v1');
      localStorage.removeItem('triggersDevPage_rawDataBuffer_v2');
      localStorage.removeItem('triggersDevPage_rawDataBuffer_v3');

      // Clear any conversation caches
      localStorage.removeItem(`conversations_${brandId}`);

      console.log('[StreamingAPI] üóëÔ∏è Cleared all localStorage caches for brand:', brandId);
    } catch (e) {
      console.warn('[StreamingAPI] Failed to clear localStorage:', e);
    }

    // Reset early loading state to allow full reload
    this.earlyLoadingStarted = false;
    this.earlyLoadBrandId = null;

    // Clear raw data buffer
    this.rawDataBuffer = [];
  }

  /**
   * Load all APIs in parallel with streaming updates
   * Now accepts profile type and UVP for intelligent API gating and query generation
   */
  async loadAllApis(
    brandId: string,
    brand: any,
    options?: {
      profileType?: BusinessProfileType;
      uvp?: CompleteUVP | null;
      forceFresh?: boolean; // Skip cache and force all APIs to fire
    }
  ): Promise<void> {
    const forceFresh = options?.forceFresh ?? false;

    // GUARD: Prevent duplicate/concurrent calls for the same brand (unless forceFresh)
    if (this.isLoadingApis && this.currentLoadBrandId === brandId && !forceFresh) {
      console.log('[StreamingAPI] ‚ö†Ô∏è Ignoring duplicate loadAllApis call - already loading for brand:', brandId);
      return;
    }

    // If loading a different brand, that's a legitimate new request
    if (this.isLoadingApis && this.currentLoadBrandId !== brandId) {
      console.log('[StreamingAPI] ‚ö†Ô∏è New brand requested while loading - allowing switch from', this.currentLoadBrandId, 'to', brandId);
    }

    this.isLoadingApis = true;
    this.currentLoadBrandId = brandId;

    // FORCE FRESH: Clear all caches to ensure APIs actually fire
    if (forceFresh) {
      console.log('[StreamingAPI] üîÑ FORCE FRESH MODE - clearing all caches');
      this.clearAllCaches(brandId);
      // Also clear Supabase caches (async, fire and forget - don't block)
      this.clearSupabaseTriggerCaches(brandId);
    }

    // Track forceFresh for use in API gating (skip stale competitor-voice cache)
    this.currentForceFresh = forceFresh;

    console.log('[StreamingAPI] Starting optimized parallel load of all APIs', forceFresh ? '(FORCE FRESH)' : '');
    const startTime = performance.now();

    // Determine profile type - use provided or fall back to NAICS-based detection
    const profileType = options?.profileType || this.detectProfileFromBrand(brand);

    // Generate psychology-focused search queries
    const searchQueries = triggerSearchQueryGenerator.generateQueries({
      uvp: options?.uvp,
      brand,
      profileType,
    });

    console.log('[StreamingAPI] Profile:', profileType, '| Target:', searchQueries.targetCustomer);

    // Store for use in API calls and trigger synthesis
    this.currentSearchQueries = searchQueries;
    this.currentProfileType = profileType;
    this.currentUVP = options?.uvp || null;
    this.currentBrandName = brand.name || '';
    // FIXED: Use UVP-derived product category instead of NAICS code
    // This ensures "conversational AI" instead of "Software Publishers"
    this.currentIndustry = this.extractProductCategoryFromUVP(
      options?.uvp || null,
      brand.industry || searchQueries.industry || ''
    );

    // Clear raw data buffer for new load
    this.rawDataBuffer = [];

    // First, emit all cached data immediately (< 50ms) - SKIP if forceFresh
    if (!forceFresh) {
      const cachedData = this.getCachedData(brandId);
      if (Object.keys(cachedData).length > 0) {
        this.emit('cache-loaded', cachedData);
        console.log('[StreamingAPI] Cached data emitted in', (performance.now() - startTime).toFixed(0), 'ms');
      }
    }

    // Build API call map based on profile type
    const apiCalls = new Map<string, () => Promise<void>>();

    // Profile-based API gating
    const apiGating = this.getAPIGatingForProfile(profileType);

    // Add Weather API only for outdoor/local businesses
    if (apiGating.useWeather) {
      apiCalls.set('weather-conditions', () => this.loadWeatherApi(brand));
    }

    // Add LinkedIn/G2 only for B2B profiles
    if (apiGating.useLinkedIn) {
      apiCalls.set('linkedin-company', () => this.loadLinkedInData(brand));
    }

    // Add local review APIs only for local businesses
    if (apiGating.useLocalReviews) {
      apiCalls.set('outscraper-data', () => this.loadOutscraperData(brand));
    }

    // Universal APIs (always run for all profile types)
    // NOTE: Skipping news-api (broken module import), using Serper news instead
    // apiCalls.set('news-breaking', () => this.loadNewsApi(brand));
    apiCalls.set('serper-search', () => this.loadSerperQuickData(brand));
    apiCalls.set('website-analysis', () => this.loadWebsiteAnalysis(brand));
    apiCalls.set('serper-full', () => this.loadSerperFullData(brand));
    apiCalls.set('apify-data', () => this.loadApifyData(brand));
    apiCalls.set('apify-social-data', () => this.loadApifySocialData(brand));
    apiCalls.set('semrush-data', () => this.loadSemrushData(brand));
    apiCalls.set('perplexity-research', () => this.loadPerplexityData(brand));

    // DISABLED: Competitor Voice loads stale cached Supabase data (brand_competitor_voice)
    // The old data was generated with fear-focused queries and pollutes fresh Perplexity results.
    // TODO: Re-enable after clearing stale data or implementing proper cache invalidation
    // apiCalls.set('competitor-voice', () => this.loadCompetitorVoiceData(brandId));
    console.log('[StreamingAPI] ‚è≠Ô∏è DISABLED competitor-voice cache - using only fresh Perplexity data');

    // PHASE 4 DISABLED FOR B2B: YouTube comments are general public sentiment, not buyer intent
    // Re-enable only for B2C profiles where consumer sentiment matters
    if (!this.isB2BProfile(profileType)) {
      apiCalls.set('youtube-trending', () => this.loadYouTubeApi(brand));
      console.log(`[StreamingAPI] ‚úÖ YouTube enabled for ${profileType} (B2C consumer sentiment)`);
    } else {
      console.log(`[StreamingAPI] ‚è≠Ô∏è Skipping YouTube for ${profileType} (B2B - no buyer intent signals)`);
    }

    // Profile-gated Reddit - High value for B2B SaaS & tech, less relevant for local-only businesses
    if (apiGating.useReddit) {
      apiCalls.set('reddit-intelligence', () => this.loadRedditData(brand));
      console.log(`[StreamingAPI] ‚úÖ Reddit enabled for ${profileType} profile`);
    } else {
      console.log(`[StreamingAPI] ‚è≠Ô∏è Skipping Reddit for ${profileType} profile`);
    }

    // =========================================================================
    // PHASE J: Multi-Source Trigger Integration
    // Add News Events, HackerNews, Reddit Conversations, LinkedIn Signals
    // =========================================================================

    // News Event Triggers - Funding, acquisitions, leadership changes (all profiles)
    apiCalls.set('news-event-triggers', () => this.loadNewsEventTriggers(brand));
    console.log(`[StreamingAPI] ‚úÖ News Event Triggers enabled`);

    // HackerNews - Tech community switching signals (tech/SaaS profiles only)
    if (this.isTechProfile(profileType)) {
      apiCalls.set('hackernews-triggers', () => this.loadHackerNewsTriggers(brand));
      console.log(`[StreamingAPI] ‚úÖ HackerNews triggers enabled for ${profileType} profile`);
    } else {
      console.log(`[StreamingAPI] ‚è≠Ô∏è Skipping HackerNews for ${profileType} profile (non-tech)`);
    }

    // Reddit Conversations - UVP pain point community validation (Reddit-enabled profiles)
    if (apiGating.useReddit && this.currentUVP) {
      apiCalls.set('reddit-conversations', () => this.loadRedditConversations(brand));
      console.log(`[StreamingAPI] ‚úÖ Reddit Conversations enabled for ${profileType} profile`);
    }

    // LinkedIn Executive Signals - B2B profiles only
    if (this.isB2BProfile(profileType)) {
      apiCalls.set('linkedin-executive-signals', () => this.loadLinkedInExecutiveSignals(brand));
      console.log(`[StreamingAPI] ‚úÖ LinkedIn Executive Signals enabled for ${profileType} profile`);
    } else {
      console.log(`[StreamingAPI] ‚è≠Ô∏è Skipping LinkedIn Executive Signals for ${profileType} profile (B2C)`);
    }

    // =========================================================================
    // SYNAPSE 2.0: Hidden Data Sources
    // SEC EDGAR + BuzzSumo for unique competitive intelligence
    // =========================================================================

    // SEC EDGAR - Industry intelligence from 10-K filings (B2B tech only)
    if (this.isB2BProfile(profileType) && this.isTechProfile(profileType)) {
      apiCalls.set('sec-edgar-intelligence', () => this.loadSECEdgarIntelligence(brand));
      console.log(`[StreamingAPI] ‚úÖ SEC EDGAR enabled for ${profileType} profile`);
    }

    // BuzzSumo - Content performance + trend timing (all profiles)
    apiCalls.set('buzzsumo-performance', () => this.loadBuzzSumoPerformance(brand));
    console.log(`[StreamingAPI] ‚úÖ BuzzSumo Performance enabled`);

    console.log(`[StreamingAPI] Running ${apiCalls.size} APIs for ${profileType} profile`);

    // Use performance optimizer to load in optimal order
    const optimizedCalls = performanceOptimizer.optimizeLoadOrder(apiCalls);

    // Execute all optimized calls
    await Promise.allSettled(optimizedCalls);

    // Log performance metrics
    const totalTime = performance.now() - startTime;
    const report = performanceOptimizer.getPerformanceReport();

    console.log('[StreamingAPI] All APIs loaded in', totalTime.toFixed(0), 'ms');
    console.log('[StreamingAPI] Performance Report:', {
      averageLoadTime: report.averageLoadTime.toFixed(0) + 'ms',
      fastestAPI: report.fastestAPI,
      slowestAPI: report.slowestAPI,
      apisLoaded: apiCalls.size,
      profileType: profileType,
      apiGating: apiGating
    });

    // Save combined data to cache
    this.saveToCacheasync(brandId);

    // Emit complete event so consumers know API loading is done
    this.emit('complete', {
      totalTime,
      apisLoaded: apiCalls.size,
      report
    });

    // Run V1-style multi-pass trigger synthesis if we have UVP and raw data
    if (this.currentUVP && this.rawDataBuffer.length > 0) {
      console.log(`[StreamingAPI] üéØ Starting V1-style multi-pass synthesis with ${this.rawDataBuffer.length} samples`);

      // PHASE M: Pre-filter raw data for relevance to UVP/industry before synthesis
      // This prevents generic Twitter chatter from polluting the synthesis
      const filteredBuffer = this.filterRawDataForRelevance(
        this.rawDataBuffer,
        this.currentUVP,
        this.currentIndustry
      );
      console.log(`[StreamingAPI] üìä After relevance filter: ${filteredBuffer.length}/${this.rawDataBuffer.length} samples`);

      // Build brand profile for V1 synthesis
      const brandProfile: BrandProfile = {
        uvp: this.currentUVP,
        profileType: this.currentProfileType,
        brandName: this.currentBrandName,
        industry: this.currentIndustry,
      };

      try {
        // V1-STYLE: 4 sequential passes with hard provenance constraints
        // PHASE M: Pass brandId for mutex lock and use filtered buffer
        const synthesisResult = await triggerSynthesisService.runMultiPass(
          brandProfile,
          filteredBuffer,
          // Progressive callback for each pass
          (passResult) => {
            console.log(`[StreamingAPI] üîÑ Pass ${passResult.passType}: ${passResult.triggers.length} triggers in ${passResult.duration.toFixed(0)}ms`);
            this.emit('trigger-batch', {
              triggers: passResult.triggers,
              batchIndex: ['pain-fear', 'desire-motivation', 'objection-trust', 'competitor'].indexOf(passResult.passType),
              totalBatches: 4,
              isComplete: false,
            });
          },
          brandId // Pass brandId for mutex
        );

        if (synthesisResult.triggers.length > 0) {
          console.log(`[StreamingAPI] ‚úÖ V1 synthesis complete: ${synthesisResult.triggers.length} triggers (deduped ${synthesisResult.deduplicatedCount})`);

          // Add UVP alignments to triggers
          const triggersWithUVP = this.addUVPAlignments(synthesisResult.triggers, this.currentUVP);

          this.emit('trigger-synthesis', {
            triggers: triggersWithUVP,
            source: 'v1-multipass',
            duration: synthesisResult.totalDuration,
          });
        } else {
          console.log('[StreamingAPI] No triggers synthesized from V1 passes');
        }
      } catch (error) {
        console.error('[StreamingAPI] V1 trigger synthesis failed:', error);
      }
    } else {
      console.log('[StreamingAPI] Skipping trigger synthesis - no UVP or raw data');
    }

    // Reset loading guard
    this.isLoadingApis = false;
    this.currentLoadBrandId = null;
    console.log('[StreamingAPI] ‚úÖ Loading complete - guard reset');
  }

  /**
   * Fast APIs (typically < 5 seconds)
   */
  private loadFastApis(brand: any): Promise<void>[] {
    return [
      this.loadWeatherApi(brand),
      // Skipping news-api, using Serper news instead
      this.loadSerperQuickData(brand),
    ];
  }

  /**
   * Medium APIs (5-15 seconds)
   */
  private loadMediumApis(brand: any): Promise<void>[] {
    return [
      this.loadYouTubeApi(brand),
      this.loadWebsiteAnalysis(brand),
      this.loadSerperFullData(brand),
    ];
  }

  /**
   * Slow APIs (15-60 seconds)
   */
  private loadSlowApis(brand: any): Promise<void>[] {
    return [
      this.loadApifyData(brand),
      this.loadOutscraperData(brand),
      this.loadSemrushData(brand),
      this.loadLinkedInData(brand),
      this.loadPerplexityData(brand),
    ];
  }

  // Individual API loaders that emit updates immediately

  private async loadWeatherApi(brand: any): Promise<void> {
    const type: ApiEventType = 'weather-conditions';

    // Check if this industry needs weather data
    const apiSelection = selectAPIsForIndustry(brand.naicsCode);
    if (!apiSelection.useWeatherAPI) {
      console.log(`[StreamingAPI] Skipping Weather API for ${brand.name} - not needed for this industry`);
      this.updateStatus(type, 'success'); // Mark as success but skip
      return;
    }

    this.updateStatus(type, 'loading');

    try {
      // Import dynamically to avoid circular deps
      const { WeatherAPI } = await import('./weather-api');
      const data = await WeatherAPI.getCurrentWeather(brand.location || 'San Francisco');

      this.emitUpdate(type, data, false);
      this.updateStatus(type, 'success');
    } catch (error) {
      this.handleApiError(type, error as Error);
    }
  }

  private async loadNewsApi(brand: any): Promise<void> {
    const breakingType: ApiEventType = 'news-breaking';
    const trendingType: ApiEventType = 'news-trending';

    this.updateStatus(breakingType, 'loading');
    this.updateStatus(trendingType, 'loading');

    try {
      const { NewsAPI } = await import('./news-api');

      // Fire both news requests in parallel
      const [breaking, trending] = await Promise.allSettled([
        NewsAPI.getIndustryNews(brand.industry, brand.keywords || []),
        NewsAPI.getLocalNews(brand.location || 'United States')
      ]);

      if (breaking.status === 'fulfilled') {
        this.emitUpdate(breakingType, breaking.value, false);
        this.updateStatus(breakingType, 'success');
      } else {
        this.handleApiError(breakingType, breaking.reason);
      }

      if (trending.status === 'fulfilled') {
        this.emitUpdate(trendingType, trending.value, false);
        this.updateStatus(trendingType, 'success');
      } else {
        this.handleApiError(trendingType, trending.reason);
      }
    } catch (error) {
      this.handleApiError(breakingType, error as Error);
      this.handleApiError(trendingType, error as Error);
    }
  }

  private async loadSerperQuickData(brand: any): Promise<void> {
    const searchType: ApiEventType = 'serper-search';
    const quoraType: ApiEventType = 'serper-quora';

    this.updateStatus(searchType, 'loading');
    this.updateStatus(quoraType, 'loading');

    try {
      const { SerperAPI } = await import('./serper-api');

      // Quick search for immediate results
      const quickSearch = await SerperAPI.searchGoogle(brand.name);
      this.emitUpdate(searchType, quickSearch, false);
      this.updateStatus(searchType, 'success');

      // Quora extraction (through Serper)
      const quoraQuery = `site:quora.com ${brand.industry} ${brand.keywords?.join(' ')}`;
      const quoraData = await SerperAPI.searchGoogle(quoraQuery);
      this.emitUpdate(quoraType, quoraData, false);
      this.updateStatus(quoraType, 'success');
    } catch (error) {
      this.handleApiError(searchType, error as Error);
      this.handleApiError(quoraType, error as Error);
    }
  }

  private async loadYouTubeApi(brand: any): Promise<void> {
    const trendingType: ApiEventType = 'youtube-trending';
    const commentsType: ApiEventType = 'youtube-comments';
    const engagementType: ApiEventType = 'youtube-engagement';

    this.updateStatus(trendingType, 'loading');
    this.updateStatus(commentsType, 'loading');
    this.updateStatus(engagementType, 'loading');

    try {
      const { YouTubeAPI } = await import('./youtube-api');
      // PHASE 4: Use PRODUCT CATEGORY pain keywords instead of NAICS industry code
      // brand.industry = "Software Publishers" (NAICS) - too generic, returns marketing videos
      // this.currentIndustry = "AI agent" (product category) - specific, returns customer pain discussions
      const productCategory = this.currentIndustry || brand.industry || 'AI software';
      const industryKeywords = [
        `${productCategory} problems`,
        `${productCategory} frustrated`,
        `${productCategory} issues`,
        `${productCategory} hate`,
        `${productCategory} mistakes`,
        ...(brand.keywords || []).slice(0, 3)
      ];
      console.log(`[StreamingAPI] üé¨ YouTube searching PRODUCT CATEGORY pain points: ${industryKeywords.slice(0, 3).join(', ')}...`);

      // Fallback data for when YouTube API fails
      const fallbackTrending = [
        { title: 'Industry Trends Update', views: 150000, engagement: 0.08 },
        { title: 'Best Practices Guide', views: 75000, engagement: 0.12 },
        { title: 'Market Analysis 2025', views: 50000, engagement: 0.10 }
      ];

      const fallbackPsychology = {
        patterns: [
          { pattern: 'Value for money', type: 'desire', frequency: 0.35 },
          { pattern: 'Quality concerns', type: 'fear', frequency: 0.25 },
          { pattern: 'Customer service', type: 'frustration', frequency: 0.20 }
        ]
      };

      const fallbackEngagement = {
        avgEngagementRate: 0.08,
        peakPostingTimes: ['9:00 AM', '12:00 PM', '5:00 PM'],
        trending_topics: ['innovation', 'customer-focus', 'efficiency']
      };

      // Get trending videos with retry and fallback
      const trending = await apiRetryWrapper.executeWithRetry(
        () => YouTubeAPI.getTrendingVideos(brand.category),
        `youtube-trending-${brand.id}`,
        {
          maxRetries: 2,
          fallbackData: fallbackTrending,
          timeout: 15000
        }
      );
      this.emitUpdate(trendingType, trending, false);
      this.updateStatus(trendingType, 'success');

      // Mine psychology with retry and fallback
      // PHASE 4 FIX: Reduced from 20 to 5 videos - each video fetches 50 comments sequentially via Apify
      // With ~10s per video, 5 videos = ~50s which fits in 90s timeout
      const psychology = await apiRetryWrapper.executeWithRetry(
        () => YouTubeAPI.mineIndustryPsychology(industryKeywords, 5),
        `youtube-psychology-${brand.id}`,
        {
          maxRetries: 2,
          fallbackData: fallbackPsychology,
          timeout: 90000 // 90s timeout for 5 videos √ó 50 comments each
        }
      );
      // PHASE 4 FIX: Emit with correct structure so bufferRawData can find data.comments
      this.emitUpdate(commentsType, psychology, false);
      this.updateStatus(commentsType, 'success');
      console.log(`[StreamingAPI] üé¨ YouTube mined ${psychology.comments?.length || 0} comments, ${psychology.patterns?.length || 0} patterns`);

      // Analyze engagement with retry and fallback
      const engagement = await apiRetryWrapper.executeWithRetry(
        () => YouTubeAPI.analyzeVideoTrends(brand.industry, industryKeywords),
        `youtube-engagement-${brand.id}`,
        {
          maxRetries: 2,
          fallbackData: fallbackEngagement,
          timeout: 15000
        }
      );
      this.emitUpdate(engagementType, engagement, false);
      this.updateStatus(engagementType, 'success');
    } catch (error) {
      this.handleApiError(trendingType, error as Error);
      this.handleApiError(commentsType, error as Error);
      this.handleApiError(engagementType, error as Error);
    }
  }

  private async loadWebsiteAnalysis(brand: any): Promise<void> {
    const type: ApiEventType = 'website-analysis';
    const keywordsType: ApiEventType = 'keywords-intent';
    this.updateStatus(type, 'loading');
    this.updateStatus(keywordsType, 'loading');

    try {
      const { websiteAnalysisService } = await import('./website-analysis.service');
      const analysis = await websiteAnalysisService.analyze(brand.website);

      this.emitUpdate(type, analysis, false);
      this.updateStatus(type, 'success');

      // Trigger keyword extraction from the website analysis (T+100ms parallel start)
      // This fires keywords-intent event which the sidebar can consume
      try {
        const { keywordExtractionService } = await import('../keywords/keyword-extraction.service');
        const brandId = brand.id || brand.name || brand.website;
        const domain = brand.website?.replace(/^https?:\/\//, '').replace(/^www\./, '').split('/')[0];

        const extractedKeywords = keywordExtractionService.extractFromWebsiteAnalysis(
          brandId,
          domain || brand.name,
          {
            title: analysis?.title || analysis?.metaTags?.title,
            metaDescription: analysis?.metaTags?.description,
            metaKeywords: analysis?.metaTags?.keywords,
            h1s: analysis?.h1s,
            ogTitle: analysis?.metaTags?.['og:title'],
            ogDescription: analysis?.metaTags?.['og:description'],
            schemaData: analysis?.schemaData,
          }
        );

        this.emitUpdate(keywordsType, extractedKeywords, false);
        this.updateStatus(keywordsType, 'success');

        // Also trigger SEMrush validation in parallel
        this.loadKeywordValidation(brandId, domain || brand.name, extractedKeywords.keywords, brand.name);
      } catch (kwError) {
        console.warn('[StreamingAPI] Keyword extraction failed:', kwError);
        this.handleApiError(keywordsType, kwError as Error);
      }
    } catch (error) {
      this.handleApiError(type, error as Error);
      this.handleApiError(keywordsType, error as Error);
    }
  }

  private async loadKeywordValidation(brandId: string, domain: string, extractedKeywords: any[], brandName?: string): Promise<void> {
    const type: ApiEventType = 'keywords-validated';
    this.updateStatus(type, 'loading');

    try {
      const { keywordValidationService } = await import('../keywords/keyword-validation.service');
      const validatedKeywords = await keywordValidationService.validateKeywords(
        brandId,
        domain,
        extractedKeywords,
        brandName
      );

      this.emitUpdate(type, validatedKeywords, false);
      this.updateStatus(type, 'success');
    } catch (error) {
      console.warn('[StreamingAPI] Keyword validation failed:', error);
      this.handleApiError(type, error as Error);
    }
  }

  private async loadSerperFullData(brand: any): Promise<void> {
    const newsType: ApiEventType = 'serper-news';
    this.updateStatus(newsType, 'loading');

    try {
      const { SerperAPI } = await import('./serper-api');

      // Get comprehensive news coverage
      const newsResults = await SerperAPI.getNews(brand.name, brand.industry);
      this.emitUpdate(newsType, newsResults, false);
      this.updateStatus(newsType, 'success');
    } catch (error) {
      this.handleApiError(newsType, error as Error);
    }
  }

  private async loadApifyData(brand: any): Promise<void> {
    const websiteType: ApiEventType = 'apify-website';
    const mapsType: ApiEventType = 'apify-maps';
    const reviewsType: ApiEventType = 'apify-reviews';
    const instagramType: ApiEventType = 'apify-instagram';

    this.updateStatus(websiteType, 'loading');
    this.updateStatus(mapsType, 'loading');
    this.updateStatus(reviewsType, 'loading');
    this.updateStatus(instagramType, 'loading');

    try {
      const { ApifyAPI } = await import('./apify-api');

      // Fire all Apify requests in parallel
      const results = await Promise.allSettled([
        ApifyAPI.scrapeWebsiteContent(brand.website),
        ApifyAPI.scrapeGoogleMapsReviews({ searchQuery: brand.name }),
        brand.instagram ? ApifyAPI.scrapeInstagramBasic(brand.instagram) : Promise.resolve(null)
      ]);

      // Process website scraping
      if (results[0].status === 'fulfilled') {
        this.emitUpdate(websiteType, results[0].value, false);
        this.updateStatus(websiteType, 'success');
      } else {
        this.handleApiError(websiteType, results[0].reason);
      }

      // Process Google Maps data
      if (results[1].status === 'fulfilled') {
        const mapsData = results[1].value;
        this.emitUpdate(mapsType, mapsData, false);
        this.updateStatus(mapsType, 'success');

        // Extract reviews separately
        const reviews = mapsData?.flatMap((place: any) => place.reviews || []) || [];
        this.emitUpdate(reviewsType, reviews, false);
        this.updateStatus(reviewsType, 'success');
      } else {
        this.handleApiError(mapsType, results[1].reason);
        this.handleApiError(reviewsType, results[1].reason);
      }

      // Process Instagram data
      if (results[2].status === 'fulfilled' && results[2].value) {
        this.emitUpdate(instagramType, results[2].value, false);
        this.updateStatus(instagramType, 'success');
      } else if (results[2].status === 'rejected') {
        this.handleApiError(instagramType, results[2].reason);
      } else {
        this.updateStatus(instagramType, 'success'); // No Instagram handle
      }
    } catch (error) {
      this.handleApiError(websiteType, error as Error);
      this.handleApiError(mapsType, error as Error);
      this.handleApiError(reviewsType, error as Error);
      this.handleApiError(instagramType, error as Error);
    }
  }

  /**
   * Load social media psychological trigger data via Apify
   * Twitter, Quora, LinkedIn (B2B only), TrustPilot, G2 (B2B only)
   *
   * Uses profile-based gating instead of NAICS codes
   */
  private async loadApifySocialData(brand: any): Promise<void> {
    const twitterType: ApiEventType = 'apify-twitter-sentiment';
    const quoraType: ApiEventType = 'apify-quora-insights';
    const linkedinType: ApiEventType = 'apify-linkedin-b2b';
    const trustpilotType: ApiEventType = 'apify-trustpilot-reviews';
    const g2Type: ApiEventType = 'apify-g2-reviews';

    // Use profile-based API gating (not NAICS codes)
    const apiGating = this.getAPIGatingForProfile(this.currentProfileType);

    console.log(`[StreamingAPI] Social data gating for ${this.currentProfileType}:`,
      `LinkedIn=${apiGating.useLinkedIn}, G2=${apiGating.useG2}, Trustpilot=${apiGating.useTrustpilot}`
    );

    // Start all applicable scrapers based on profile gating
    this.updateStatus(twitterType, 'loading');
    this.updateStatus(quoraType, 'loading');

    if (apiGating.useTrustpilot) {
      this.updateStatus(trustpilotType, 'loading');
    }
    if (apiGating.useLinkedIn) {
      this.updateStatus(linkedinType, 'loading');
    }
    if (apiGating.useG2) {
      this.updateStatus(g2Type, 'loading');
    }

    try {
      const { apifySocialScraper } = await import('./apify-social-scraper.service');

      // Build keywords using UVP-derived product category (e.g., "conversational AI" not "Software Publishers")
      // Use this.currentIndustry which is already set via extractProductCategoryFromUVP()
      const productCategory = this.currentIndustry || brand.industry || 'AI software';
      const searchQueries = this.currentSearchQueries;
      const targetCustomer = searchQueries?.targetCustomer || brand.targetCustomers || '';

      // PHASE M FIX: Use BUYER-FOCUSED keywords, not generic product terms
      // The problem: Searching "conversational AI problems" returns generic AI chatter
      // The fix: Search for what the TARGET BUYER complains about in THEIR industry context
      //
      // Example for OpenDialog (conversational AI for insurance):
      // BAD:  ["conversational AI", "conversational AI problems", "conversational AI frustrated"]
      // GOOD: ["insurance customer service automation", "insurance chatbot failing", "insurance agency COO frustrated"]

      // Extract buyer role from target customer statement
      const buyerRole = this.extractBuyerRole(targetCustomer);
      const buyerIndustry = this.extractBuyerIndustry(targetCustomer) || productCategory;

      const keywords = [
        // Primary: Buyer + industry + pain context
        `${buyerIndustry} ${buyerRole} frustrated`,
        `${buyerIndustry} ${buyerRole} switching`,
        `${buyerIndustry} customer service problems`,
        // Fallback: Product category with buyer context
        `${productCategory} implementation failing`,
        `why we left ${productCategory}`,
      ].filter(Boolean);

      console.log('[StreamingAPI] Social search keywords (BUYER-FOCUSED):', keywords.slice(0, 3));
      console.log('[StreamingAPI] Extracted buyer role:', buyerRole, '| industry:', buyerIndustry);

      // Execute scrapers in parallel with proper error boundaries
      // PHASE 5: Increased limits for more data points (Twitter 30‚Üí50, Quora 20‚Üí35)
      const scrapers: Promise<any>[] = [
        // Universal scrapers (all profiles)
        apifySocialScraper.scrapeTwitterSentiment(keywords, 50)
          .then(data => ({ type: twitterType, data }))
          .catch(error => ({ type: twitterType, error })),

        apifySocialScraper.scrapeQuoraInsights(keywords, 35)
          .then(data => ({ type: quoraType, data }))
          .catch(error => ({ type: quoraType, error })),
      ];

      // PHASE M FIX: Use UVP-derived product category for review searches, NOT brand name
      // Searching "OpenDialog" returns nothing - search "conversational AI platform" instead
      const reviewSearchCategory = productCategory || buyerIndustry || brand.industry || 'AI software';
      console.log(`[StreamingAPI] üéØ Review search using UVP category: "${reviewSearchCategory}" (not brand name)`);

      // Add Trustpilot for B2C profiles (PHASE 5: 40‚Üí60)
      if (apiGating.useTrustpilot) {
        scrapers.push(
          apifySocialScraper.scrapeTrustPilotReviews(reviewSearchCategory, 60)
            .then(data => ({ type: trustpilotType, data }))
            .catch(error => ({ type: trustpilotType, error }))
        );
      } else {
        this.updateStatus(trustpilotType, 'success');
      }

      // Add LinkedIn for B2B profiles
      if (apiGating.useLinkedIn) {
        scrapers.push(
          apifySocialScraper.scrapeLinkedInB2B(reviewSearchCategory, buyerIndustry || brand.industry, this.currentProfileType)
            .then(data => ({ type: linkedinType, data }))
            .catch(error => ({ type: linkedinType, error }))
        );
      } else {
        console.log(`[StreamingAPI] Skipping LinkedIn for ${brand.name} - ${this.currentProfileType} profile`);
        this.updateStatus(linkedinType, 'success');
      }

      // Add G2 for B2B SaaS profiles (PHASE 5: 40‚Üí60)
      // PHASE M: Search by UVP product category, not brand name
      if (apiGating.useG2) {
        scrapers.push(
          apifySocialScraper.scrapeG2Reviews(reviewSearchCategory, productCategory, 60)
            .then(data => ({ type: g2Type, data }))
            .catch(error => ({ type: g2Type, error }))
        );
      } else {
        console.log(`[StreamingAPI] Skipping G2 for ${brand.name} - ${this.currentProfileType} profile`);
        this.updateStatus(g2Type, 'success');
      }

      // PHASE M: Add Capterra for B2B SaaS (similar to G2)
      if (apiGating.useG2) { // Same gating as G2
        scrapers.push(
          this.scrapeCapterraByCategory(reviewSearchCategory, 40)
            .then(data => ({ type: 'apify-capterra-reviews' as ApiEventType, data }))
            .catch(error => ({ type: 'apify-capterra-reviews' as ApiEventType, error }))
        );
      }

      // Wait for all scrapers to complete
      const results = await Promise.allSettled(scrapers);

      // Process each result with proper error handling
      results.forEach(result => {
        if (result.status === 'fulfilled') {
          const { type, data, error } = result.value;

          if (error) {
            console.warn(`[StreamingAPI] ${type} encountered error:`, error);
            this.handleApiError(type, error);
          } else if (data) {
            console.log(`[StreamingAPI] ${type} completed successfully`);
            this.emitUpdate(type, data, false);
            this.updateStatus(type, 'success');
          }
        } else {
          console.error('[StreamingAPI] Social scraper promise rejected:', result.reason);
        }
      });

      const activeScrapers = scrapers.length;
      console.log(`[StreamingAPI] Social media scraping complete - ${activeScrapers} sources for ${this.currentProfileType}`);

    } catch (error) {
      console.error('[StreamingAPI] Social scraping batch error:', error);

      // Mark all as errored
      this.handleApiError(twitterType, error as Error);
      this.handleApiError(quoraType, error as Error);

      if (apiGating.useTrustpilot) {
        this.handleApiError(trustpilotType, error as Error);
      }
      if (apiGating.useLinkedIn) {
        this.handleApiError(linkedinType, error as Error);
      }
      if (apiGating.useG2) {
        this.handleApiError(g2Type, error as Error);
      }
    }
  }

  private async loadOutscraperData(brand: any): Promise<void> {
    const businessType: ApiEventType = 'outscraper-business';
    const reviewsType: ApiEventType = 'outscraper-reviews';

    this.updateStatus(businessType, 'loading');
    this.updateStatus(reviewsType, 'loading');

    try {
      const { OutScraperAPI } = await import('./outscraper-api');

      // Get Google business data
      const businessData = await OutScraperAPI.getBusinessListings({
        query: brand.name,
        location: brand.location || 'United States',
        limit: 20
      });
      this.emitUpdate(businessType, businessData, false);
      this.updateStatus(businessType, 'success');

      // Extract reviews using Maps Search first (no place_id available)
      const reviews = await OutScraperAPI.scrapeGoogleReviews({
        place_id: '', // Will use business_name fallback
        business_name: brand.name,
        location: brand.location || 'United States',
        industry: brand.industry,
        limit: 50
      });
      this.emitUpdate(reviewsType, reviews, false);
      this.updateStatus(reviewsType, 'success');
    } catch (error) {
      this.handleApiError(businessType, error as Error);
      this.handleApiError(reviewsType, error as Error);
    }
  }

  private async loadSemrushData(brand: any): Promise<void> {
    const domainType: ApiEventType = 'semrush-domain';
    const keywordsType: ApiEventType = 'semrush-keywords';
    const competitorsType: ApiEventType = 'semrush-competitors';
    const backlinksType: ApiEventType = 'semrush-backlinks';

    this.updateStatus(domainType, 'loading');
    this.updateStatus(keywordsType, 'loading');
    this.updateStatus(competitorsType, 'loading');
    this.updateStatus(backlinksType, 'loading');

    try {
      const { SemrushAPI } = await import('./semrush-api');

      // Parse domain from website URL
      const domain = new URL(brand.website).hostname;

      // Fire all SEMrush requests in parallel
      const results = await Promise.allSettled([
        SemrushAPI.getDomainOverview(domain),
        SemrushAPI.getKeywordRankings(domain, brand.name),
        SemrushAPI.getCompetitorKeywords(domain),
        SemrushAPI.getKeywordOpportunities(domain, brand.name)
      ]);

      // Process each result independently
      if (results[0].status === 'fulfilled') {
        this.emitUpdate(domainType, results[0].value, false);
        this.updateStatus(domainType, 'success');
      } else {
        this.handleApiError(domainType, results[0].reason);
      }

      if (results[1].status === 'fulfilled') {
        this.emitUpdate(keywordsType, results[1].value, false);
        this.updateStatus(keywordsType, 'success');
      } else {
        this.handleApiError(keywordsType, results[1].reason);
      }

      if (results[2].status === 'fulfilled') {
        this.emitUpdate(competitorsType, results[2].value, false);
        this.updateStatus(competitorsType, 'success');
      } else {
        this.handleApiError(competitorsType, results[2].reason);
      }

      if (results[3].status === 'fulfilled') {
        this.emitUpdate(backlinksType, results[3].value, false);
        this.updateStatus(backlinksType, 'success');
      } else {
        this.handleApiError(backlinksType, results[3].reason);
      }
    } catch (error) {
      this.handleApiError(domainType, error as Error);
      this.handleApiError(keywordsType, error as Error);
      this.handleApiError(competitorsType, error as Error);
      this.handleApiError(backlinksType, error as Error);
    }
  }

  private async loadLinkedInData(brand: any): Promise<void> {
    const companyType: ApiEventType = 'linkedin-company';
    const networkType: ApiEventType = 'linkedin-network';

    // Check if this industry needs LinkedIn data
    const apiSelection = selectAPIsForIndustry(brand.naicsCode);
    if (!apiSelection.useLinkedInAPI) {
      console.log(`[StreamingAPI] Skipping LinkedIn API for ${brand.name} - not needed for this industry`);
      this.updateStatus(companyType, 'success'); // Mark as success but skip
      this.updateStatus(networkType, 'success'); // Mark as success but skip
      return;
    }

    this.updateStatus(companyType, 'loading');
    this.updateStatus(networkType, 'loading');

    try {
      const { LinkedInAPI } = await import('./linkedin-api');

      // Get company and network insights
      const [company, network] = await Promise.allSettled([
        LinkedInAPI.getCompanyInfo(brand.linkedinHandle || brand.name),
        LinkedInAPI.getNetworkInsights(brand.linkedinHandle || brand.name)
      ]);

      if (company.status === 'fulfilled') {
        this.emitUpdate(companyType, company.value, false);
        this.updateStatus(companyType, 'success');
      } else {
        this.handleApiError(companyType, company.reason);
      }

      if (network.status === 'fulfilled') {
        this.emitUpdate(networkType, network.value, false);
        this.updateStatus(networkType, 'success');
      } else {
        this.handleApiError(networkType, network.reason);
      }
    } catch (error) {
      this.handleApiError(companyType, error as Error);
      this.handleApiError(networkType, error as Error);
    }
  }

  private async loadPerplexityData(brand: any): Promise<void> {
    const type: ApiEventType = 'perplexity-research';
    this.updateStatus(type, 'loading');

    try {
      const { perplexityAPI } = await import('../uvp-wizard/perplexity-api');

      // Use generated search queries if available, otherwise fall back to brand data
      const searchQueries = this.currentSearchQueries;
      const targetCustomer = searchQueries?.targetCustomer || brand.targetCustomers || brand.industry || 'business decision makers';
      const industry = searchQueries?.industry || brand.industry || 'business services';

      // PHASE M: Extract FULL UVP data for query generation
      // This includes differentiators, benefits, products, emotional drivers, transformations
      const uvpDerivedQueries = triggerSearchQueryGenerator.generateUVPDerivedQueries(
        this.currentUVP,
        this.currentProfileType
      );
      const fullUVPData = triggerSearchQueryGenerator.extractFullUVPData(this.currentUVP);

      // Build rich context from ALL UVP components
      const productKeywords = this.extractProductKeywords(this.currentUVP);
      const productContext = productKeywords.length > 0
        ? productKeywords.slice(0, 3).join(', ')
        : industry;

      // PHASE M: Build buyer psychology context from UVP
      const emotionalDriversContext = fullUVPData.emotionalDrivers.slice(0, 3).join('; ') || 'business pain points';
      const functionalDriversContext = fullUVPData.functionalDrivers.slice(0, 3).join('; ') || 'operational needs';
      const transformationContext = fullUVPData.transformationBefore
        ? `moving from "${fullUVPData.transformationBefore}" to "${fullUVPData.transformationAfter}"`
        : 'business transformation';
      const differentiatorContext = fullUVPData.differentiators.slice(0, 2).join('; ') || productContext;

      console.log(`[StreamingAPI] PHASE M: Full UVP-derived search context:`, {
        emotionalDrivers: emotionalDriversContext.substring(0, 60),
        functionalDrivers: functionalDriversContext.substring(0, 60),
        transformation: transformationContext.substring(0, 60),
        differentiators: differentiatorContext.substring(0, 60),
      });

      // PROFILE-AWARE SOURCE GUIDANCE: Tell Perplexity which platforms matter for this profile
      const sourceGuidance = this.getPerplexitySourceGuidance(this.currentProfileType);
      console.log(`[StreamingAPI] Perplexity search for: ${targetCustomer} in ${industry}`);
      console.log(`[StreamingAPI] Product keywords for query specificity: ${productContext}`);
      console.log(`[StreamingAPI] Source guidance for ${this.currentProfileType}: ${sourceGuidance}`);

      // PHASE C: Log trigger event queries being used
      if (searchQueries?.triggerEventQueries?.length) {
        console.log(`[StreamingAPI] Phase C: Adding ${Math.min(2, searchQueries.triggerEventQueries.length)} trigger event queries`);
      }
      if (searchQueries?.highIntentQueries?.length) {
        console.log(`[StreamingAPI] Phase C: Adding ${Math.min(2, searchQueries.highIntentQueries.length)} high-intent queries`);
      }

      // PHASE L: STRUCTURED JSON EXTRACTION
      // The problem: Prose instructions get ignored, Perplexity returns meta-commentary
      // The fix: Demand structured JSON output with explicit required fields
      // If no real quotes exist, we get empty array (clean failure) not garbage
      const STRUCTURED_JSON_FORMAT = `
Return ONLY a valid JSON array. No other text. Format:
[
  {
    "quote": "exact first-person quote (I, We, Our team...)",
    "speaker": "role or name if known (e.g., 'IT Director', 'anonymous user')",
    "source_url": "full URL where quote appears",
    "platform": "G2|Reddit|LinkedIn|Capterra|TrustRadius|other",
    "emotion": "frustrated|angry|disappointed|worried|hopeful|excited"
  }
]

CRITICAL RULES:
- Return [] (empty array) if you cannot find REAL quotes with sources
- NEVER return descriptions like "G2 reviews show..." - those are NOT quotes
- NEVER return "No quotes found..." - just return []
- Each quote MUST be first-person (I, We, Our, My)
- Each quote MUST have a real source_url (not just the platform homepage)
`;

      // Build buyer-focused context (not just product category)
      const buyerContext = `${targetCustomer} evaluating ${productContext}`;
      console.log(`[StreamingAPI] Perplexity buyer context: ${buyerContext}`);

      // PHASE M: Use FULL UVP data for psychology queries
      const psychologyQueries = searchQueries ? [
        // 1. EMOTIONAL DRIVER PAIN - People experiencing what our buyers feel
        `Search for first-person quotes from ${targetCustomer} expressing: ${emotionalDriversContext}
Context: Find quotes where people express these EXACT emotional pain points.
Keywords: "frustrated", "worried", "overwhelmed", "can't keep up", "falling behind"
${sourceGuidance}
${STRUCTURED_JSON_FORMAT}`,

        // 2. TRANSFORMATION GAP - People stuck in the "before" state
        `Search for quotes from ${targetCustomer} stuck in this situation: ${transformationContext}
Context: Find people expressing frustration with their current state who want to transform.
Keywords: "still using", "stuck with", "wish we could", "trying to move away from"
${sourceGuidance}
${STRUCTURED_JSON_FORMAT}`,

        // 3. FUNCTIONAL DRIVER NEEDS - People needing what our product does
        `Search for quotes from ${targetCustomer} who need: ${functionalDriversContext}
Context: Find buyers actively looking for solutions to these functional needs.
Keywords: "need to", "looking for", "how do I", "requirement", "must have"
${sourceGuidance}
${STRUCTURED_JSON_FORMAT}`,

        // 4. DIFFERENTIATOR PAIN - People without what makes us unique
        `Search for quotes from ${targetCustomer} frustrated by lack of: ${differentiatorContext}
Context: Find people experiencing pain because existing solutions DON'T have our differentiators.
Keywords: "doesn't have", "missing", "wish it had", "can't find", "no solution for"
${sourceGuidance}
${STRUCTURED_JSON_FORMAT}`,

        // 5. SWITCHING INTENT - Highest value triggers (buyer-focused)
        `Search for first-person quotes from ${targetCustomer} switching ${productContext} vendors.
Context: Find quotes from actual buyers/users, NOT reviews of random companies.
Keywords: "we switched", "migrating from", "why we left", "moving to"
${sourceGuidance}
${STRUCTURED_JSON_FORMAT}`,

        // 6. IMPLEMENTATION FAILURES - Post-purchase reality from buyers
        `Search for quotes from ${targetCustomer} about ${productContext} implementation problems.
Context: Focus on buyer experiences, not generic software reviews.
Keywords: "took longer", "hidden costs", "didn't work as expected", "regret"
${sourceGuidance}
${STRUCTURED_JSON_FORMAT}`,

        // 7. COMPARISON DISCUSSIONS - Active evaluation by target buyers
        `Search for quotes from ${targetCustomer} comparing ${productContext} alternatives.
Context: Buyers actively evaluating options, not generic comparisons.
Keywords: "vs", "compared to", "evaluating", "which is better"
${sourceGuidance}
${STRUCTURED_JSON_FORMAT}`,

        // 8. CONTRACT/LOCK-IN FEARS - Vendor concerns
        `Search for quotes about ${productContext} vendor lock-in concerns.
Keywords: "trapped", "can't leave", "contract", "migration nightmare"
${sourceGuidance}
${STRUCTURED_JSON_FORMAT}`,

        // ========================================
        // PHASE C: PROFILE-SPECIFIC TRIGGER EVENTS
        // ========================================
        // Add high-intent trigger queries from Phase C (if available)
        ...(searchQueries.triggerEventQueries?.slice(0, 2).map(query =>
          `${query}
${sourceGuidance}
${STRUCTURED_JSON_FORMAT}`
        ) || []),

        // Add high-intent signal queries (if available)
        ...(searchQueries.highIntentQueries?.slice(0, 2).map(query =>
          `${query}
${sourceGuidance}
${STRUCTURED_JSON_FORMAT}`
        ) || []),

      ] : [
        // Fallback queries with same structured format
        `Quotes about switching ${productContext} vendors. ${STRUCTURED_JSON_FORMAT}`,
        `Frustration quotes about ${productContext}. ${STRUCTURED_JSON_FORMAT}`,
        `Implementation failure quotes for ${productContext}. ${STRUCTURED_JSON_FORMAT}`,
        `Support nightmare quotes for ${productContext}. ${STRUCTURED_JSON_FORMAT}`,
        `Pricing complaint quotes for ${productContext}. ${STRUCTURED_JSON_FORMAT}`,
        `Missing feature quotes for ${productContext}. ${STRUCTURED_JSON_FORMAT}`,
        `Comparison quotes for ${productContext}. ${STRUCTURED_JSON_FORMAT}`,
        `Vendor lock-in quotes for ${productContext}. ${STRUCTURED_JSON_FORMAT}`,
      ];

      // Run all queries in parallel - TARGET 200 DATA POINTS (10 queries x 20 results = 200)
      const results = await Promise.allSettled(
        psychologyQueries.map(query =>
          perplexityAPI.getIndustryInsights({
            query,
            context: {
              industry: industry,
              // Don't pass brand name - we want psychology, not brand mentions
            },
            max_results: 20 // Increased to 20 per query (10 queries √ó 20 = 200 potential insights)
          })
        )
      );

      // PHASE L: Import quote validator for structured validation
      const { quoteValidatorService } = await import('../triggers/quote-validator.service');

      // PHASE L: Structured quote extraction with validation
      // Instead of filtering prose garbage, we extract structured JSON and validate each quote
      interface StructuredQuote {
        quote: string;
        speaker?: string;
        source_url: string;
        platform: string;
        emotion?: string;
      }

      interface ValidatedInsight {
        insight: string;
        sources: Array<{ title: string; url: string; excerpt: string }>;
        isValidated: boolean;
        validationReason?: string;
      }

      const validatedInsights: ValidatedInsight[] = [];
      const allSources: Array<{ title: string; url: string; excerpt: string }> = [];
      let rejectedCount = 0;
      let jsonParseSuccessCount = 0;
      let jsonParseFailCount = 0;

      // Helper to try extracting JSON from response
      const tryExtractJSON = (text: string): StructuredQuote[] | null => {
        try {
          // Clean potential markdown code fences
          let cleaned = text.trim();
          cleaned = cleaned.replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/```\s*$/i, '');

          // Find JSON array
          const jsonStart = cleaned.indexOf('[');
          const jsonEnd = cleaned.lastIndexOf(']');
          if (jsonStart >= 0 && jsonEnd > jsonStart) {
            cleaned = cleaned.substring(jsonStart, jsonEnd + 1);
          }

          const parsed = JSON.parse(cleaned);
          if (Array.isArray(parsed)) {
            return parsed as StructuredQuote[];
          }
          return null;
        } catch {
          return null;
        }
      };

      // Helper to validate URL is real (not just platform homepage)
      const isValidSourceUrl = (url: string): boolean => {
        if (!url || !url.startsWith('http')) return false;
        try {
          const parsed = new URL(url);
          // Reject if just homepage (path is / or empty)
          if (parsed.pathname === '/' || parsed.pathname === '') return false;
          // Reject perplexity URLs
          if (parsed.hostname.includes('perplexity.ai')) return false;
          return true;
        } catch {
          return false;
        }
      };

      // Process results with structured extraction
      for (const [idx, result] of results.entries()) {
        if (result.status !== 'fulfilled') {
          console.warn(`[StreamingAPI] Perplexity query ${idx} failed:`, result.reason);
          continue;
        }

        const { insights, sources } = result.value;

        // Collect sources from this query
        if (sources && sources.length > 0) {
          allSources.push(...sources);
        }

        // Try to extract structured JSON from each insight
        for (const insight of insights) {
          // First, try to parse as JSON (our new format)
          const structuredQuotes = tryExtractJSON(insight);

          if (structuredQuotes && structuredQuotes.length > 0) {
            jsonParseSuccessCount++;

            // Validate each quote in the JSON array
            for (const sq of structuredQuotes) {
              // Skip if no quote text
              if (!sq.quote || sq.quote.length < 20) {
                rejectedCount++;
                continue;
              }

              // Skip if no valid source URL
              if (!isValidSourceUrl(sq.source_url)) {
                rejectedCount++;
                console.log(`[StreamingAPI] Rejected (invalid URL): "${sq.quote.slice(0, 40)}..."`);
                continue;
              }

              // Validate with quote validator
              const validation = await quoteValidatorService.validateQuote(sq.quote);
              if (!validation.isReal) {
                rejectedCount++;
                console.log(`[StreamingAPI] Rejected (${validation.reason}): "${sq.quote.slice(0, 40)}..."`);
                continue;
              }

              // Valid quote! Add it
              validatedInsights.push({
                insight: sq.quote,
                sources: [{
                  title: sq.speaker || 'Customer Quote',
                  url: sq.source_url,
                  excerpt: sq.quote
                }],
                isValidated: true,
                validationReason: validation.reason
              });
            }
          } else {
            // Fallback: not JSON, try to validate as prose quote
            jsonParseFailCount++;

            // Validate with quote validator
            const validation = await quoteValidatorService.validateQuote(insight);
            if (!validation.isReal) {
              rejectedCount++;
              console.log(`[StreamingAPI] Rejected prose (${validation.reason}): "${insight.slice(0, 50)}..."`);
              continue;
            }

            // It's a valid quote, but we need a URL
            // Try to find a matching source from the sources array
            const matchingSource = sources?.find((s: any) =>
              s.excerpt?.toLowerCase().includes(insight.toLowerCase().slice(0, 30))
            );

            if (matchingSource && isValidSourceUrl(matchingSource.url)) {
              validatedInsights.push({
                insight,
                sources: [matchingSource],
                isValidated: true,
                validationReason: validation.reason
              });
            } else if (sources && sources.length > 0 && isValidSourceUrl(sources[0].url)) {
              // Use first available source if quote validated
              validatedInsights.push({
                insight,
                sources: [sources[0]],
                isValidated: true,
                validationReason: validation.reason
              });
            } else {
              // No valid source URL, reject
              rejectedCount++;
              console.log(`[StreamingAPI] Rejected (no valid URL): "${insight.slice(0, 50)}..."`);
            }
          }
        }
      }

      console.log(`[StreamingAPI] Perplexity PHASE L: ${validatedInsights.length} validated quotes (rejected ${rejectedCount})`);
      console.log(`[StreamingAPI] JSON parse: ${jsonParseSuccessCount} success, ${jsonParseFailCount} fallback to prose`);

      // Emit combined results WITH sources preserved
      this.emitUpdate(type, {
        insights: validatedInsights.map(i => i.insight),
        insightsWithSources: validatedInsights.map(vi => ({
          insight: vi.insight,
          sources: vi.sources
        })),
        sources: allSources.slice(0, 30), // Cap to prevent bloat
        confidence: 0.85,
        profileType: this.currentProfileType,
        targetCustomer,
        industry,
        // PHASE L: Add validation metadata
        validationStats: {
          validated: validatedInsights.length,
          rejected: rejectedCount,
          jsonParseSuccess: jsonParseSuccessCount,
          proseValidated: jsonParseFailCount - rejectedCount
        }
      }, false);
      this.updateStatus(type, 'success');
    } catch (error) {
      this.handleApiError(type, error as Error);
    }
  }

  /**
   * Load Reddit data via Apify Reddit scraper
   * Direct Reddit intelligence for psychological triggers
   */
  private async loadRedditData(brand: any): Promise<void> {
    console.log('[StreamingAPI] üî¥ Loading Reddit data for:', brand.name);

    try {
      const { redditAPI } = await import('./reddit-apify-api');

      // Use UVP-derived product category (e.g., "conversational AI" not "Software Publishers")
      const productCategory = this.currentIndustry || brand.industry || 'AI software';
      const searchQueries = this.currentSearchQueries;
      const targetCustomer = searchQueries?.targetCustomer || brand.targetCustomers || 'users';

      // Build V1-aligned search query for B2B vs B2C
      // V1 FIX: For B2B, search for END CUSTOMER problems, not target customer problems
      let searchQuery: string;

      if (this.isB2BProfile(this.currentProfileType)) {
        // B2B: Search for what the target customer's customers are saying
        // Example: OpenDialog sells to insurance brokers ‚Üí search for insurance buyer problems
        const endCustomerContext = this.extractEndCustomerContext(targetCustomer, productCategory);
        searchQuery = `${endCustomerContext} problems frustrated shopping buying`;
      } else {
        // B2C: Search for direct customer problems
        searchQuery = `${productCategory} ${targetCustomer} problems frustrated`;
      }

      console.log('[StreamingAPI] Reddit search query (product-specific):', searchQuery);

      // Find relevant subreddits using product category
      const subreddits = await redditAPI.findRelevantSubreddits(productCategory);
      console.log('[StreamingAPI] Reddit subreddits:', subreddits.slice(0, 3));

      // Mine intelligence - TARGET 200 DATA POINTS
      // Phase 2 scaling: Increased limits for 30+ triggers
      const result = await redditAPI.mineIntelligence(searchQuery, {
        subreddits: subreddits.slice(0, 6), // Increased from 4 to 6 subreddits
        limit: 50, // Increased from 30 to 50 posts
        commentsPerPost: 20, // Increased from 15 to 20 comments per post
        sortBy: 'hot',
        timeFilter: 'month'
      });

      // FIXED: Also buffer if rawPosts exist (even if pattern matching found 0 triggers/insights)
      const hasContent = result.triggers.length > 0 || result.insights.length > 0 || (result.rawPosts && result.rawPosts.length > 0);

      if (hasContent) {
        console.log(`[StreamingAPI] ‚úÖ Reddit returned ${result.triggers.length} triggers, ${result.insights.length} insights, ${result.rawPosts?.length || 0} raw posts`);

        // Emit as custom event type (not in ApiEventType enum, but we can still emit)
        this.emit('reddit-intelligence', {
          type: 'reddit-intelligence',
          data: result,
          timestamp: Date.now(),
          fromCache: false
        });

        // Also buffer for LLM synthesis - rawPosts will be included even if triggers/insights are 0
        this.bufferRedditData(result);
      } else {
        console.log('[StreamingAPI] Reddit returned no results (0 triggers, 0 insights, 0 raw posts)');
      }
    } catch (error) {
      console.error('[StreamingAPI] Reddit loading failed:', error);
      // Non-blocking - don't throw
    }
  }

  /**
   * Buffer Reddit data for LLM trigger synthesis
   * FIXED: Now also buffers raw posts even if no patterns matched
   */
  private bufferRedditData(result: any): void {
    if (!result) return;

    const samples: RawDataSample[] = [];

    // Buffer triggers (if pattern matching found any)
    if (result.triggers && result.triggers.length > 0) {
      result.triggers.forEach((trigger: any, idx: number) => {
        if (trigger.text && trigger.text.length > 20) {
          samples.push({
            id: `reddit-trigger-${idx}`,
            content: trigger.context || trigger.text,
            source: `r/${trigger.subreddit}`,
            platform: 'Reddit',
            url: trigger.url,
          });
        }
      });
    }

    // Buffer insights (pain points and desires)
    if (result.insights && result.insights.length > 0) {
      result.insights.forEach((insight: any, idx: number) => {
        const content = insight.painPoint || insight.desire || insight.context;
        if (content && content.length > 20) {
          samples.push({
            id: `reddit-insight-${idx}`,
            content,
            source: `r/${insight.subreddit}`,
            platform: 'Reddit',
            url: insight.url,
          });
        }
      });
    }

    // FIXED: Buffer ALL raw posts with synthetic Reddit URLs
    // Apify Reddit scraper returns: post.url, post.postUrl, post.subreddit, post.subredditName, post.text, post.selftext
    if (result.rawPosts && result.rawPosts.length > 0) {
      console.log(`[StreamingAPI] üî¥ Processing ${result.rawPosts.length} raw Reddit posts for buffering`);
      result.rawPosts.forEach((post: any, idx: number) => {
        // Handle both Apify formats: selftext or text
        const bodyText = post.selftext || post.text || post.selfText || '';
        const title = post.title || '';
        const content = title + (bodyText ? '. ' + bodyText : '');
        // LOWERED minimum from 30 to 15 characters - titles alone are valuable
        if (content && content.length > 15) {
          // Get subreddit from either format
          const subreddit = post.subreddit || post.subredditName || 'unknown';
          const postId = post.id || post.postId || `post-${idx}`;
          // Use existing URL/permalink or generate synthetic
          const postUrl = post.url || post.postUrl || post.permalink;
          const syntheticUrl = postUrl && postUrl.includes('reddit.com')
            ? postUrl
            : `https://reddit.com/r/${subreddit}/comments/${postId}`;

          samples.push({
            id: `reddit-post-${idx}`,
            content: content.substring(0, 500),
            source: `r/${subreddit}`,
            platform: 'reddit',
            url: syntheticUrl,
            sourceTitle: post.title?.substring(0, 100) || 'Reddit post',
          });
        }

        // ALSO buffer comments from this post
        if (post.comments && Array.isArray(post.comments)) {
          post.comments.forEach((comment: any, cIdx: number) => {
            const commentText = comment.body || comment.text || comment.content;
            // LOWERED minimum from 20 to 10 characters
            if (commentText && commentText.length > 10) {
              const subreddit = post.subreddit || post.subredditName || 'unknown';
              const commentId = comment.id || `comment-${cIdx}`;
              samples.push({
                id: `reddit-comment-${idx}-${cIdx}`,
                content: commentText.substring(0, 500),
                source: `r/${subreddit} comment`,
                platform: 'reddit',
                url: `https://reddit.com/r/${subreddit}/comments/${post.id || postId}/_/${commentId}`,
                sourceTitle: commentText.substring(0, 80) + '...',
              });
            }
          });
        }
      });
    }

    // Reddit samples always have valid URLs now (synthetic if needed)
    if (samples.length > 0) {
      this.rawDataBuffer.push(...samples);
      console.log(`[StreamingAPI] üî¥ Buffered ${samples.length} Reddit samples (total: ${this.rawDataBuffer.length})`);
    }
  }

  /**
   * Alias for loadPerplexityData - AI insights via Perplexity
   * Used by optimized-api-loader.service.ts
   */
  async loadAIInsights(brand: any): Promise<void> {
    return this.loadPerplexityData(brand);
  }

  /**
   * OpenRouter AI analysis - currently uses same implementation as Perplexity
   * Used by optimized-api-loader.service.ts
   */
  async loadAIAnalysis(brand: any): Promise<void> {
    // For now, use the same implementation as Perplexity
    // TODO: Implement proper OpenRouter analysis when API is configured
    return this.loadPerplexityData(brand);
  }

  // Helper methods

  /**
   * PHASE M: Filter raw data samples for relevance AND prioritize by source quality
   * 1. Filters out irrelevant Twitter chatter
   * 2. Reorders: Perplexity/G2/Capterra FIRST, Twitter LAST
   * 3. Caps Twitter to 10 samples max
   */
  private filterRawDataForRelevance(
    samples: RawDataSample[],
    uvp: CompleteUVP | null,
    industry: string
  ): RawDataSample[] {
    if (!uvp) return samples;

    // Build relevance keywords from UVP
    const relevanceKeywords = this.buildRelevanceKeywords(uvp, industry);
    console.log(`[StreamingAPI] Relevance filter keywords: ${relevanceKeywords.slice(0, 10).join(', ')}`);

    // PHASE M: Source quality tiers
    const SOURCE_PRIORITY: Record<string, number> = {
      'perplexity': 1,      // Highest - AI-validated quotes
      'g2': 2,              // B2B reviews
      'capterra': 2,        // B2B reviews
      'trustpilot': 2,      // Consumer reviews
      'trustradius': 2,     // B2B reviews
      'reddit': 3,          // Discussions
      'hackernews': 3,      // Tech discussions
      'linkedin': 3,        // B2B signals
      'sec-edgar': 3,       // Enterprise signals
      'quora': 4,           // Q&A
      'twitter': 5,         // LOWEST - most noise
      'x': 5,               // LOWEST
    };

    // Filter and categorize samples
    const twitterSamples: RawDataSample[] = [];
    const otherSamples: RawDataSample[] = [];

    for (const sample of samples) {
      const platform = sample.platform.toLowerCase();
      const isTwitter = platform.includes('twitter') || platform.includes('x');
      const content = sample.content.toLowerCase();

      if (isTwitter) {
        // PHASE M: Twitter requires 3+ relevance keywords (was 2)
        const matchCount = relevanceKeywords.filter(kw => content.includes(kw)).length;
        if (matchCount >= 3) {
          twitterSamples.push(sample);
        } else if (twitterSamples.length < 3) {
          // Log first few rejections
          console.log(`[StreamingAPI] üö´ Rejected Twitter (${matchCount}/3 keywords): ${content.substring(0, 60)}...`);
        }
      } else {
        // Non-Twitter: always keep
        otherSamples.push(sample);
      }
    }

    // PHASE M: Sort non-Twitter by source priority
    otherSamples.sort((a, b) => {
      const platformA = a.platform.toLowerCase();
      const platformB = b.platform.toLowerCase();

      const priorityA = Object.entries(SOURCE_PRIORITY).find(([key]) => platformA.includes(key))?.[1] || 4;
      const priorityB = Object.entries(SOURCE_PRIORITY).find(([key]) => platformB.includes(key))?.[1] || 4;

      return priorityA - priorityB;
    });

    // PHASE M: Cap Twitter to 10 samples max
    const TWITTER_CAP = 10;
    const cappedTwitter = twitterSamples.slice(0, TWITTER_CAP);

    // Combine: quality sources FIRST, Twitter LAST
    const filtered = [...otherSamples, ...cappedTwitter];

    // Log results
    const twitterRejected = twitterSamples.length - cappedTwitter.length;
    console.log(`[StreamingAPI] üìä Source prioritization:`, {
      perplexity: otherSamples.filter(s => s.platform.toLowerCase().includes('perplexity')).length,
      g2_capterra: otherSamples.filter(s => s.platform.toLowerCase().includes('g2') || s.platform.toLowerCase().includes('capterra')).length,
      reddit: otherSamples.filter(s => s.platform.toLowerCase().includes('reddit')).length,
      twitter: `${cappedTwitter.length} (capped from ${twitterSamples.length}, rejected ${samples.length - twitterSamples.length - otherSamples.length})`,
      total: filtered.length,
    });

    return filtered;
  }

  /**
   * PHASE M: Scrape Capterra by category (not brand name)
   */
  private async scrapeCapterraByCategory(category: string, limit: number = 40): Promise<any> {
    try {
      const { apifySocialScraper } = await import('./apify-social-scraper.service');

      // Map category to Capterra URL
      const categorySlug = category.toLowerCase()
        .replace(/[^a-z0-9\s]/g, '')
        .replace(/\s+/g, '-');

      // Capterra category URLs follow pattern: capterra.com/categories/{slug}/
      const capterraUrl = `https://www.capterra.com/categories/${categorySlug}/`;

      console.log(`[StreamingAPI] Scraping Capterra category: ${capterraUrl}`);

      // Use generic web scraper to get reviews from category page
      const results = await apifySocialScraper.runSocialScraper('CAPTERRA', {
        startUrls: [{ url: capterraUrl }],
        maxRequestsPerCrawl: 30,
        maxCrawlDepth: 2,
      });

      return {
        reviews: results || [],
        category,
        source: 'capterra-category',
      };
    } catch (error) {
      console.warn('[StreamingAPI] Capterra category scrape failed:', error);
      return { reviews: [], category, error };
    }
  }

  /**
   * Build relevance keywords from UVP for filtering
   */
  private buildRelevanceKeywords(uvp: CompleteUVP, industry: string): string[] {
    const keywords: Set<string> = new Set();

    // Industry-specific keywords
    keywords.add(industry.toLowerCase());

    // From UVP components
    const uvpTexts = [
      uvp.uniqueSolution?.statement,
      uvp.keyBenefit?.statement,
      uvp.targetCustomer?.statement,
      typeof uvp.whatYouDo === 'string' ? uvp.whatYouDo : (uvp.whatYouDo as any)?.statement,
    ].filter(Boolean);

    // Extract meaningful words (4+ chars, not common words)
    const stopWords = new Set(['that', 'this', 'with', 'have', 'from', 'they', 'been', 'will', 'would', 'could', 'should', 'their', 'there', 'about', 'which', 'when', 'what', 'your', 'more', 'than', 'into', 'also', 'them', 'most', 'just', 'over', 'such', 'some', 'very', 'only', 'come', 'make', 'like', 'back', 'even', 'want', 'give', 'well', 'need', 'take', 'help', 'work', 'first', 'because', 'through', 'after', 'before', 'while', 'where', 'being', 'other', 'these', 'those', 'each', 'under', 'between']);

    for (const text of uvpTexts) {
      if (!text) continue;
      const words = text.toLowerCase().match(/\b[a-z]{4,}\b/g) || [];
      words.forEach(word => {
        if (!stopWords.has(word)) {
          keywords.add(word);
        }
      });
    }

    // Add industry-specific trigger words
    const industryTriggerWords: Record<string, string[]> = {
      'insurance': ['insurance', 'claims', 'policy', 'coverage', 'agent', 'broker', 'carrier', 'underwriting', 'risk', 'compliance'],
      'healthcare': ['healthcare', 'patient', 'clinical', 'medical', 'health', 'hospital', 'provider', 'care', 'treatment'],
      'financial': ['financial', 'banking', 'payment', 'transaction', 'compliance', 'fraud', 'account', 'lending'],
      'saas': ['software', 'platform', 'integration', 'api', 'dashboard', 'subscription', 'enterprise', 'deployment'],
      'retail': ['retail', 'customer', 'store', 'inventory', 'commerce', 'shopping', 'checkout', 'cart'],
    };

    // Add industry-specific words
    for (const [key, words] of Object.entries(industryTriggerWords)) {
      if (industry.toLowerCase().includes(key)) {
        words.forEach(w => keywords.add(w));
      }
    }

    // Always include buyer intent words
    ['frustrated', 'switching', 'looking for', 'need', 'problem', 'issue', 'hate', 'love', 'amazing', 'terrible', 'compared to', 'versus', 'vs', 'alternative'].forEach(w => keywords.add(w));

    return Array.from(keywords);
  }

  /**
   * Buffer raw data samples for LLM trigger synthesis
   * Extracts text content from various API response formats
   */
  private bufferRawData(type: ApiEventType, data: any): void {
    if (!data) return;

    const samples: RawDataSample[] = [];

    // Extract from different API response formats
    if (type === 'perplexity-research') {
      // Use insightsWithSources if available (has citation URLs)
      if (data.insightsWithSources && Array.isArray(data.insightsWithSources)) {
        data.insightsWithSources.forEach((item: { insight: string; sources: Array<{ title: string; url: string; excerpt: string }> }, idx: number) => {
          if (item.insight && item.insight.length > 20) {
            // Get the first source URL if available
            const primarySource = item.sources?.[0];
            // FIXED: Label URL-less insights as "AI Research" instead of rejecting them
            const hasUrl = primarySource?.url && primarySource.url.startsWith('http');
            samples.push({
              id: `perp-${idx}`,
              content: item.insight,
              // Use actual source title, or "AI Research" for URL-less insights
              source: hasUrl ? (primarySource?.title || 'Industry research') : 'AI Research',
              platform: hasUrl ? this.extractPlatformFromUrl(primarySource!.url) : 'ai-research',
              url: hasUrl ? primarySource!.url : undefined,
              sourceTitle: hasUrl ? primarySource?.title : 'AI Research',
            });
          }
        });
      } else if (data.insights) {
        // OLD FORMAT: No source URLs - label as AI Research
        console.log('[StreamingAPI] ‚ö†Ô∏è Perplexity returned insights without source citations - labeling as AI Research');
        data.insights.forEach((insight: string, idx: number) => {
          if (insight && insight.length > 20) {
            samples.push({
              id: `perp-old-${idx}`,
              content: insight,
              source: 'AI Research',
              platform: 'ai-research',
              url: undefined,
              sourceTitle: 'AI Research',
            });
          }
        });
      }
    }

    if (type === 'apify-twitter-sentiment' && data.tweets) {
      data.tweets.forEach((tweet: any, idx: number) => {
        const tweetText = tweet.text || tweet.content;
        if (tweetText && tweetText.length > 20) {
          // Generate a synthetic URL for Twitter/X - the tweet itself IS the source
          // Format: x.com/username/status/id or just x.com if no details
          const author = tweet.author || tweet.username || 'unknown';
          const tweetId = tweet.id || tweet.tweetId || `tweet-${idx}`;
          const syntheticUrl = tweet.url || `https://x.com/${author.replace('@', '')}/status/${tweetId}`;

          samples.push({
            id: `twitter-${idx}`,
            content: tweetText,
            source: `@${author.replace('@', '')} on X`, // e.g., "@user on X"
            platform: 'X',
            url: syntheticUrl,
            // Store the full tweet as evidence - the tweet IS the source
            sourceTitle: tweetText.substring(0, 100) + (tweetText.length > 100 ? '...' : ''),
          });
        }
      });
    }

    if (type === 'apify-trustpilot-reviews' || type === 'apify-g2-reviews' || type === 'outscraper-reviews') {
      // FIXED: Handle both data.reviews array AND data itself being reviews array
      const reviews = data.reviews || (Array.isArray(data) ? data : []);
      const platform = type.includes('g2') ? 'G2' : type.includes('trustpilot') ? 'Trustpilot' : 'Google';

      console.log(`[StreamingAPI] üìù Buffering ${reviews.length} ${platform} reviews`);

      reviews.forEach((review: any, idx: number) => {
        // G2/Trustpilot may have text in different fields
        const reviewText = review.text || review.content || review.pros || review.cons || '';
        if (reviewText && reviewText.length > 20) {
          samples.push({
            id: `review-${type}-${idx}`,
            content: reviewText,
            source: review.author || platform,
            platform: platform.toLowerCase(),
            url: review.url || `https://www.${platform.toLowerCase()}.com`,
            sourceTitle: reviewText.substring(0, 100) + (reviewText.length > 100 ? '...' : ''),
          });
        }
      });
    }

    if (type === 'apify-quora-insights' && (data.questions || data.answers)) {
      const items = [...(data.questions || []), ...(data.answers || [])];
      items.forEach((item: any, idx: number) => {
        const content = item.text || item.content || item.question || item.answer;
        if (content) {
          samples.push({
            id: `quora-${idx}`,
            content,
            source: 'Quora',
            platform: 'quora',
            url: item.url,
          });
        }
      });
    }

    if (type === 'youtube-comments' && data.comments) {
      data.comments.forEach((comment: any, idx: number) => {
        if (comment.text || comment.content) {
          samples.push({
            id: `youtube-${idx}`,
            content: comment.text || comment.content,
            source: comment.author || 'YouTube',
            platform: 'youtube',
          });
        }
      });
    }

    if (type === 'apify-linkedin-b2b' && data.posts) {
      data.posts.forEach((post: any, idx: number) => {
        if (post.text || post.content) {
          samples.push({
            id: `linkedin-${idx}`,
            content: post.text || post.content,
            source: post.author || 'LinkedIn',
            platform: 'linkedin',
            url: post.url,
          });
        }
      });
    }

    // FIXED: Handle LinkedIn company and network data for trigger synthesis
    if ((type === 'linkedin-company' || type === 'linkedin-network') && data) {
      // Extract insights, trends, or key messages from LinkedIn company data
      const items = data.insights || data.updates || data.posts || [];
      items.forEach((item: any, idx: number) => {
        const content = item.text || item.content || item.message || item.insight;
        if (content && content.length > 20) {
          samples.push({
            id: `linkedin-${type}-${idx}`,
            content,
            source: 'LinkedIn',
            platform: 'linkedin',
            url: item.url || 'https://linkedin.com',
            sourceType: 'executive',
          });
        }
      });
    }

    // FIXED: Handle HackerNews triggers
    if (type === 'hackernews-triggers' && data) {
      const stories = data.stories || data.items || (Array.isArray(data) ? data : []);
      stories.forEach((story: any, idx: number) => {
        const content = story.title || story.text || story.content;
        if (content && content.length > 10) {
          samples.push({
            id: `hn-${idx}`,
            content,
            source: 'HackerNews',
            platform: 'hackernews',
            url: story.url || `https://news.ycombinator.com/item?id=${story.id}`,
            sourceType: 'community',
          });
        }
      });
    }

    // FIXED: Handle Serper news/search results
    if ((type === 'serper-news' || type === 'serper-full') && data) {
      const results = data.news || data.organic || data.results || [];
      results.forEach((result: any, idx: number) => {
        const content = result.snippet || result.description || result.title;
        if (content && content.length > 20) {
          samples.push({
            id: `serper-${type}-${idx}`,
            content,
            source: result.source || 'Search',
            platform: 'serper',
            url: result.link || result.url,
            sourceType: 'news',
          });
        }
      });
    }

    // FIXED: Handle news events and breaking news
    if ((type === 'news-breaking' || type === 'news-trending' || type === 'news-event-triggers') && data) {
      const articles = data.articles || data.news || data.events || (Array.isArray(data) ? data : []);
      articles.forEach((article: any, idx: number) => {
        const content = article.description || article.snippet || article.title || article.content;
        if (content && content.length > 20) {
          samples.push({
            id: `news-${type}-${idx}`,
            content,
            source: article.source || 'News',
            platform: 'news',
            url: article.url || article.link,
            sourceType: type === 'news-event-triggers' ? 'event' : 'news',
          });
        }
      });
    }

    // FIXED: Handle competitor voice data (VoC gold mine)
    if (type === 'competitor-voice' && data) {
      const voices = data.voices || data.painPoints || data.items || (Array.isArray(data) ? data : []);
      voices.forEach((voice: any, idx: number) => {
        const content = voice.text || voice.quote || voice.painPoint || voice.content;
        if (content && content.length > 20) {
          samples.push({
            id: `competitor-voice-${idx}`,
            content,
            source: voice.source || voice.competitor || 'Competitor Research',
            platform: voice.platform || 'voc',
            url: voice.url,
            sourceType: 'voc',
          });
        }
      });
    }

    // PHASE 10: Only buffer samples from TRUSTED source domains
    // Reject hallucinated/fake sources like "Spear-tech.com"
    // BUT: Allow URL-less insights from KNOWN TRUSTED PLATFORMS
    const TRUSTED_PLATFORMS_NO_URL = [
      'ai-research', 'linkedin', 'hackernews', 'sec-edgar', 'buzzsumo',
      'voc', 'news', 'serper', 'reddit', 'youtube', 'g2', 'trustpilot',
      'capterra', 'quora', 'x', 'twitter', 'competitor-research'
    ];

    const validSamples = samples.filter(s => {
      // Allow samples with no URL if they're from a KNOWN TRUSTED PLATFORM
      if (!s.url || !s.url.startsWith('http')) {
        // Keep samples from trusted internal platforms
        const platformLower = (s.platform || '').toLowerCase();
        const sourceLower = (s.source || '').toLowerCase();

        if (TRUSTED_PLATFORMS_NO_URL.some(tp =>
          platformLower.includes(tp) || sourceLower.includes(tp) ||
          s.source === 'AI Research' || s.platform === 'ai-research'
        )) {
          return true;
        }
        // Also allow if sourceType is set (indicates it came from a known source)
        if (s.sourceType) {
          return true;
        }
        return false;
      }
      // Must be from a trusted domain (rejects hallucinated sources)
      return this.isValidSourceDomain(s.url);
    });

    const rejectedCount = samples.length - validSamples.length;

    if (rejectedCount > 0) {
      console.log(`[StreamingAPI] ‚ö†Ô∏è Rejected ${rejectedCount} samples from untrusted domains from ${type}`);
    }

    // PHASE J: Tag samples with sourceType for multi-signal triangulation
    const taggedSamples = validSamples.map(s => ({
      ...s,
      sourceType: s.sourceType || this.getSourceTypeForApiType(type, s.platform)
    }));

    // Add to buffer with source distribution logging
    if (taggedSamples.length > 0) {
      this.rawDataBuffer.push(...taggedSamples);

      // Log source distribution for debugging
      const platformCounts = new Map<string, number>();
      this.rawDataBuffer.forEach(s => {
        const platform = s.platform || 'unknown';
        platformCounts.set(platform, (platformCounts.get(platform) || 0) + 1);
      });
      const distribution = Array.from(platformCounts.entries())
        .map(([p, c]) => `${p}: ${c}`)
        .join(', ');

      console.log(`[StreamingAPI] ‚úÖ Buffered ${taggedSamples.length} trusted samples from ${type} (total: ${this.rawDataBuffer.length} | ${distribution})`);
    }
  }

  /**
   * Get source type for multi-signal triangulation based on API type and platform
   * This enables confidence scoring: 2+ source types = higher confidence
   */
  private getSourceTypeForApiType(type: ApiEventType, platform?: string): RawDataSample['sourceType'] {
    // VoC (Voice of Customer) - Review platforms
    const vocTypes: ApiEventType[] = [
      'apify-g2-reviews', 'apify-trustpilot-reviews', 'outscraper-reviews',
      'competitor-voice'
    ];
    if (vocTypes.includes(type)) return 'voc';

    // Community - Social discussions
    const communityTypes: ApiEventType[] = [
      'reddit-intelligence', 'reddit-conversations', 'hackernews-triggers',
      'apify-quora-insights', 'youtube-comments'
    ];
    if (communityTypes.includes(type)) return 'community';

    // News - News and industry publications
    const newsTypes: ApiEventType[] = [
      'news-breaking', 'news-trending', 'news-event-triggers', 'serper-news'
    ];
    if (newsTypes.includes(type)) return 'news';

    // Executive - LinkedIn and B2B professional signals
    const executiveTypes: ApiEventType[] = [
      'linkedin-company', 'linkedin-network', 'linkedin-executive-signals',
      'apify-linkedin-b2b'
    ];
    if (executiveTypes.includes(type)) return 'executive';

    // Event - Trigger events (funding, acquisitions, etc.)
    if (type === 'news-event-triggers') return 'event';

    // Platform-based fallback
    if (platform) {
      const platformLower = platform.toLowerCase();
      if (['g2', 'trustpilot', 'capterra', 'gartner'].includes(platformLower)) return 'voc';
      if (['reddit', 'hackernews', 'quora', 'x', 'twitter'].includes(platformLower)) return 'community';
      if (['linkedin'].includes(platformLower)) return 'executive';
    }

    // Default to news for everything else (Perplexity, Serper, etc.)
    return 'news';
  }

  private emitUpdate(type: ApiEventType, data: any, fromCache: boolean): void {
    // Buffer raw data for LLM trigger synthesis (only for fresh data, not cache)
    if (!fromCache) {
      this.bufferRawData(type, data);
    }

    const update: ApiUpdate = {
      type,
      data,
      timestamp: Date.now(),
      fromCache
    };

    // PERMANENT FIX: Buffer events and emit in batches to prevent freeze
    // This prevents 23+ separate re-renders that each trigger extractInsightsFromDeepContext
    console.log(`[StreamingAPI] Buffering update for ${type}`);
    this.eventBuffer.set(type, update);

    // Clear existing flush timeout and schedule new one
    if (this.batchFlushTimeout) {
      clearTimeout(this.batchFlushTimeout);
    }

    // Flush batch after BATCH_WINDOW_MS (200ms) of inactivity
    this.batchFlushTimeout = setTimeout(() => {
      this.flushEventBatch();
    }, this.BATCH_WINDOW_MS);
  }

  /**
   * Flush all buffered events as a single batch
   * This causes ONE re-render instead of N re-renders
   */
  private flushEventBatch(): void {
    if (this.eventBuffer.size === 0) return;

    const batchedUpdates = Array.from(this.eventBuffer.values());
    console.log(`[StreamingAPI] Flushing batch of ${batchedUpdates.length} updates`);

    // Emit a single batch event (UI should listen to this)
    this.emit('api-batch-update', batchedUpdates);

    // Also emit individual events for backwards compatibility
    for (const update of batchedUpdates) {
      this.emit('api-update', update);
      this.emit(update.type, update);
    }

    // Clear buffer
    this.eventBuffer.clear();
    this.batchFlushTimeout = null;
  }

  private updateStatus(type: ApiEventType, status: ApiStatus['status']): void {
    const existing = this.apiStatuses.get(type) || { type, status: 'idle' };

    if (status === 'loading') {
      existing.startTime = Date.now();
    } else if (status === 'success' || status === 'error') {
      existing.endTime = Date.now();
      existing.duration = existing.endTime - (existing.startTime || 0);
    }

    existing.status = status;
    this.apiStatuses.set(type, existing);

    this.emit('status-update', existing);
  }

  private handleApiError(type: ApiEventType, error: Error): void {
    console.error(`[StreamingAPI] Error in ${type}:`, error);

    const status = this.apiStatuses.get(type) || { type, status: 'idle' };
    status.status = 'error';
    status.error = error;
    status.endTime = Date.now();
    status.duration = status.endTime - (status.startTime || 0);

    this.apiStatuses.set(type, status);

    this.emit('api-error', { type, error });
    this.emit('status-update', status);
  }

  /**
   * Diversify source data to prevent any single platform from flooding the LLM
   * Problem: VoC data can have 382 items, drowning out Reddit, Perplexity, etc.
   * Solution: Cap each platform at maxPerSource samples, keeping the most diverse mix
   */
  private diversifySourceData(samples: RawDataSample[], maxPerSource: number = 20): RawDataSample[] {
    // Group by platform
    const byPlatform = new Map<string, RawDataSample[]>();

    for (const sample of samples) {
      const platform = sample.platform || 'unknown';
      if (!byPlatform.has(platform)) {
        byPlatform.set(platform, []);
      }
      byPlatform.get(platform)!.push(sample);
    }

    // Log original distribution
    const originalDist = Array.from(byPlatform.entries())
      .map(([p, s]) => `${p}: ${s.length}`)
      .join(', ');
    console.log(`[StreamingAPI] Pre-diversification: ${originalDist}`);

    // Take max N from each platform (prioritize variety within each platform)
    const diversified: RawDataSample[] = [];

    for (const [platform, platformSamples] of byPlatform.entries()) {
      // Shuffle to get variety, then take first N
      const shuffled = [...platformSamples].sort(() => Math.random() - 0.5);
      const selected = shuffled.slice(0, maxPerSource);
      diversified.push(...selected);

      if (platformSamples.length > maxPerSource) {
        console.log(`[StreamingAPI] Capped ${platform}: ${platformSamples.length} -> ${maxPerSource}`);
      }
    }

    // Log new distribution
    const newDist = Array.from(byPlatform.keys())
      .map(p => `${p}: ${Math.min(byPlatform.get(p)!.length, maxPerSource)}`)
      .join(', ');
    console.log(`[StreamingAPI] Post-diversification: ${newDist}`);

    return diversified;
  }

  /**
   * Extract platform name from a URL for evidence attribution
   */
  private extractPlatformFromUrl(url: string): string {
    try {
      const hostname = new URL(url).hostname.toLowerCase();

      if (hostname.includes('reddit.com')) return 'Reddit';
      if (hostname.includes('g2.com')) return 'G2';
      if (hostname.includes('trustpilot.com')) return 'Trustpilot';
      if (hostname.includes('linkedin.com')) return 'LinkedIn';
      if (hostname.includes('twitter.com') || hostname.includes('x.com')) return 'Twitter';
      if (hostname.includes('quora.com')) return 'Quora';
      if (hostname.includes('youtube.com')) return 'YouTube';
      if (hostname.includes('gartner.com')) return 'Gartner';
      if (hostname.includes('forrester.com')) return 'Forrester';
      if (hostname.includes('mckinsey.com')) return 'McKinsey';
      if (hostname.includes('hbr.org')) return 'Harvard Business Review';
      if (hostname.includes('forbes.com')) return 'Forbes';
      if (hostname.includes('medium.com')) return 'Medium';
      if (hostname.includes('techcrunch.com')) return 'TechCrunch';

      // Return cleaned domain name as fallback
      return hostname.replace('www.', '').split('.')[0];
    } catch {
      return 'research';
    }
  }

  // =========================================================================
  // PHASE J: Multi-Source Trigger Integration Methods
  // =========================================================================

  /**
   * Check if profile is tech/SaaS where HackerNews data is valuable
   */
  private isTechProfile(profileType: BusinessProfileType): boolean {
    const techProfiles: BusinessProfileType[] = [
      'national-saas-b2b',
      'global-saas-b2b',
      'regional-b2b-agency'  // Tech agencies benefit from HN too
    ];
    return techProfiles.includes(profileType);
  }

  /**
   * Check if profile is B2B where LinkedIn executive signals matter
   */
  private isB2BProfile(profileType: BusinessProfileType): boolean {
    const b2bProfiles: BusinessProfileType[] = [
      'national-saas-b2b',
      'global-saas-b2b',
      'regional-b2b-agency',
      'local-service-b2b',
      // New types from brand-profile.service
      'local-b2b',
      'national-saas'
    ];
    return b2bProfiles.includes(profileType);
  }

  /**
   * Extract end customer context for B2B query construction
   * Converts target customer to their customer's problems
   *
   * Example: "Insurance broker/agency owner" ‚Üí "insurance buyers customers"
   */
  private extractEndCustomerContext(targetCustomer: string, productCategory: string): string {
    // B2B industry mappings to end customer contexts
    const industryMappings: Record<string, string> = {
      'insurance': 'insurance buyers customers shopping for coverage',
      'real estate': 'home buyers sellers real estate customers',
      'automotive': 'car buyers auto customers vehicle shoppers',
      'healthcare': 'patients healthcare customers medical',
      'finance': 'financial services customers banking clients',
      'legal': 'legal clients law firm customers',
      'accounting': 'small business owners tax clients',
      'marketing': 'marketing clients business owners',
      'consulting': 'consulting clients business executives',
      'software': 'software users technology customers'
    };

    // Extract industry from target customer or product category
    const targetLower = targetCustomer.toLowerCase();

    for (const [industry, endCustomer] of Object.entries(industryMappings)) {
      if (targetLower.includes(industry) || productCategory.toLowerCase().includes(industry)) {
        return endCustomer;
      }
    }

    // Default fallback: extract the industry and add "customers"
    const industryWords = targetCustomer.match(/(\w+)\s+(broker|agent|owner|professional|consultant)/i);
    if (industryWords && industryWords[1]) {
      return `${industryWords[1]} customers buyers clients`;
    }

    // Final fallback
    return `customers buyers clients shopping`;
  }

  /**
   * Add UVP alignment data to triggers for display in cards
   * Matches trigger content against UVP components to show relevance
   */
  private addUVPAlignments(triggers: any[], uvp: any): any[] {
    if (!uvp) return triggers;

    // Extract UVP components for matching
    const uvpComponents = {
      uniqueSolution: uvp.uniqueSolution?.statement || '',
      keyBenefit: uvp.keyBenefit?.statement || '',
      targetCustomer: uvp.targetCustomer?.statement || '',
      transformation: uvp.transformation?.statement || '',
      differentiators: (uvp.differentiators || []).map((d: any) => d.statement || '').filter(Boolean),
    };

    return triggers.map(trigger => {
      const alignments: Array<{ component: string; matchScore: number; matchReason: string }> = [];
      const triggerText = `${trigger.title} ${trigger.executiveSummary}`.toLowerCase();

      // Check against unique solution
      if (uvpComponents.uniqueSolution && this.hasSemanticOverlap(triggerText, uvpComponents.uniqueSolution.toLowerCase())) {
        alignments.push({
          component: 'unique_solution',
          matchScore: 0.85,
          matchReason: uvpComponents.uniqueSolution.substring(0, 80)
        });
      }

      // Check against key benefit
      if (uvpComponents.keyBenefit && this.hasSemanticOverlap(triggerText, uvpComponents.keyBenefit.toLowerCase())) {
        alignments.push({
          component: 'key_benefit',
          matchScore: 0.85,
          matchReason: uvpComponents.keyBenefit.substring(0, 80)
        });
      }

      // Check against target customer pain points
      if (uvpComponents.targetCustomer && this.hasSemanticOverlap(triggerText, uvpComponents.targetCustomer.toLowerCase())) {
        alignments.push({
          component: 'target_customer',
          matchScore: 0.85,
          matchReason: `Addresses target: ${uvpComponents.targetCustomer.substring(0, 60)}`
        });
      }

      // Check against transformation
      if (uvpComponents.transformation && this.hasSemanticOverlap(triggerText, uvpComponents.transformation.toLowerCase())) {
        alignments.push({
          component: 'transformation',
          matchScore: 0.85,
          matchReason: uvpComponents.transformation.substring(0, 80)
        });
      }

      // Check against differentiators
      for (const diff of uvpComponents.differentiators.slice(0, 3)) {
        if (this.hasSemanticOverlap(triggerText, diff.toLowerCase())) {
          alignments.push({
            component: 'differentiator',
            matchScore: 0.8,
            matchReason: diff.substring(0, 80)
          });
          break; // Only add one differentiator match
        }
      }

      return {
        ...trigger,
        uvpAlignments: alignments.slice(0, 3) // Max 3 alignments per trigger
      };
    });
  }

  /**
   * Check if two texts have semantic overlap (shared important keywords)
   */
  private hasSemanticOverlap(text1: string, text2: string): boolean {
    // Extract important words (skip common words)
    const stopWords = new Set(['the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
      'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might',
      'must', 'shall', 'can', 'need', 'to', 'of', 'in', 'for', 'on', 'with', 'at', 'by', 'from',
      'as', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'between', 'under',
      'again', 'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all',
      'each', 'few', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only', 'own',
      'same', 'so', 'than', 'too', 'very', 'just', 'and', 'but', 'if', 'or', 'because', 'while',
      'this', 'that', 'these', 'those', 'they', 'them', 'their', 'what', 'which', 'who', 'whom']);

    const getKeywords = (text: string): Set<string> => {
      return new Set(
        text.split(/\s+/)
          .map(w => w.replace(/[^a-z0-9]/g, ''))
          .filter(w => w.length > 3 && !stopWords.has(w))
      );
    };

    const keywords1 = getKeywords(text1);
    const keywords2 = getKeywords(text2);

    // Count overlap
    let overlap = 0;
    for (const word of keywords1) {
      if (keywords2.has(word)) overlap++;
    }

    // Need at least 2 shared keywords for alignment
    return overlap >= 2;
  }

  /**
   * Load News Event Triggers - Funding, acquisitions, leadership changes
   * These are trigger EVENTS that create buying windows
   */
  private async loadNewsEventTriggers(brand: any): Promise<void> {
    const type: ApiEventType = 'news-event-triggers';
    this.updateStatus(type, 'loading');

    try {
      const { SerperAPI } = await import('./serper-api');

      // Get competitors from brand data (passed from context)
      const competitors: string[] = brand.competitors || [];

      // Build event-focused queries for competitors
      const eventQueries = competitors.slice(0, 3).map(comp =>
        `"${comp}" (funding OR acquired OR launches OR hires OR layoffs OR announces)`
      );

      // Also search for industry-wide events
      eventQueries.push(`${brand.industry} (funding round OR acquisition OR new CEO OR expansion)`);

      const samples: RawDataSample[] = [];

      for (const query of eventQueries) {
        try {
          const news = await SerperAPI.getNews(query);

          news.slice(0, 10).forEach(article => {
            // Only include recent news (last 30 days)
            const articleDate = new Date(article.date);
            const daysAgo = (Date.now() - articleDate.getTime()) / (1000 * 60 * 60 * 24);

            if (daysAgo <= 30) {
              // Extract competitor name from query
              const competitorMatch = query.match(/"([^"]+)"/);
              const competitorName = competitorMatch ? competitorMatch[1] : undefined;

              samples.push({
                id: `news-event-${article.link.slice(-20)}`,
                content: `${article.title}. ${article.snippet}`,
                source: article.source,
                platform: 'News',
                sourceType: 'event',
                url: article.link,
                timestamp: article.date,
                author: article.source,
                competitorName
              });
            }
          });
        } catch (err) {
          console.warn(`[StreamingAPI] News query failed: ${query}`, err);
        }
      }

      // Add to raw data buffer
      if (samples.length > 0) {
        this.rawDataBuffer.push(...samples);
        console.log(`[StreamingAPI] üì∞ Buffered ${samples.length} news event samples (total: ${this.rawDataBuffer.length})`);
      }

      this.emitUpdate(type, { newsEvents: samples }, false);
      this.updateStatus(type, 'success');

    } catch (error) {
      console.error('[StreamingAPI] News Event Triggers failed:', error);
      this.updateStatus(type, 'error');
    }
  }

  /**
   * Load HackerNews Triggers - Tech community switching signals
   * High value for SaaS: "switching from X to Y", "frustrated with X", "alternatives to X"
   */
  private async loadHackerNewsTriggers(brand: any): Promise<void> {
    const type: ApiEventType = 'hackernews-triggers';
    this.updateStatus(type, 'loading');

    try {
      const { HackerNewsAPI } = await import('./hackernews-api');

      // Get competitors from brand data (passed from context)
      const competitors: string[] = brand.competitors || [];

      // Build switching/frustration queries
      const switchingQueries = [
        `${brand.industry} switching alternative`,
        `${brand.industry} frustrated hate`,
        `${brand.industry} vs comparison`,
        ...competitors.slice(0, 2).map(c => `${c} alternative`),
        ...competitors.slice(0, 2).map(c => `${c} problems issues`)
      ];

      // PHASE 3: Increased HN limits for more data points (5‚Üí15 hits/topic, 25‚Üí50 samples)
      const results = await HackerNewsAPI.searchMultiple(switchingQueries, {
        hitsPerTopic: 15,
        minPoints: 5  // Lowered threshold to catch more discussions
      });

      const samples: RawDataSample[] = results.slice(0, 50).map(hit => ({
        id: `hn-${hit.id}`,
        content: `${hit.title}. ${hit.description}`,
        source: 'HackerNews',
        platform: 'HackerNews',
        sourceType: 'community',
        url: hit.url,
        timestamp: hit.date,
        author: hit.author,
        engagement: hit.engagementScore
      }));

      // Add to raw data buffer (PHASE 3: increased cap from 25 to 50)
      if (samples.length > 0) {
        this.rawDataBuffer.push(...samples);
        console.log(`[StreamingAPI] üî∂ Buffered ${samples.length} HackerNews samples (total: ${this.rawDataBuffer.length})`);
      }

      this.emitUpdate(type, { hackerNewsInsights: samples }, false);
      this.updateStatus(type, 'success');

    } catch (error) {
      console.error('[StreamingAPI] HackerNews Triggers failed:', error);
      this.updateStatus(type, 'error');
    }
  }

  /**
   * Load Reddit Conversations - UVP pain point community validation
   * Uses mineConversations() with UVP pain points as keywords
   */
  private async loadRedditConversations(brand: any): Promise<void> {
    const type: ApiEventType = 'reddit-conversations';
    this.updateStatus(type, 'loading');

    try {
      const { redditAPI } = await import('./reddit-apify-api');

      // Extract pain points from UVP targetCustomer data
      const painPoints: string[] = [];

      // Get emotional drivers from UVP as pain point proxies
      const targetCustomer = this.currentUVP?.targetCustomer;
      if (targetCustomer?.emotionalDrivers) {
        // Emotional drivers often reflect underlying pain points
        painPoints.push(...targetCustomer.emotionalDrivers.slice(0, 3));
      }

      // Use transformation goal as a pain indicator (what they want to fix)
      const transformGoal = this.currentUVP?.transformationGoal;
      if (transformGoal?.statement) {
        painPoints.push(transformGoal.statement);
      } else if (transformGoal?.outcomeStatement) {
        painPoints.push(transformGoal.outcomeStatement);
      }

      // Fallback to industry keywords if no pain points
      if (painPoints.length === 0) {
        painPoints.push(`${brand.industry} problems`, `${brand.industry} frustrating`);
      }

      // PHASE 6: Increased Reddit conversations limit (15‚Üí30) for more data points
      const result = await redditAPI.mineConversations(
        painPoints,
        brand.industry,
        { limit: 30, timeFilter: 'month' }
      );

      const samples: RawDataSample[] = [];

      // Convert insights to samples
      result.insights.forEach((insight, idx) => {
        samples.push({
          id: `reddit-conv-insight-${idx}`,
          content: insight.painPoint || insight.desire || insight.context,
          source: `r/${insight.subreddit}`,
          platform: 'Reddit',
          sourceType: 'community',
          url: insight.url,
          engagement: insight.upvotes
        });
      });

      // Convert triggers to samples
      result.triggers.forEach((trigger, idx) => {
        samples.push({
          id: `reddit-conv-trigger-${idx}`,
          content: trigger.text,
          source: `r/${trigger.subreddit}`,
          platform: 'Reddit',
          sourceType: 'community',
          url: trigger.url,
          engagement: trigger.upvotes
        });
      });

      // Add to raw data buffer (PHASE 6: increased cap from 30 to 50)
      const cappedSamples = samples.slice(0, 50);
      if (cappedSamples.length > 0) {
        this.rawDataBuffer.push(...cappedSamples);
        console.log(`[StreamingAPI] üî¥ Buffered ${cappedSamples.length} Reddit conversation samples (total: ${this.rawDataBuffer.length})`);
      }

      this.emitUpdate(type, { redditConversations: cappedSamples }, false);
      this.updateStatus(type, 'success');

    } catch (error) {
      console.error('[StreamingAPI] Reddit Conversations failed:', error);
      this.updateStatus(type, 'error');
    }
  }

  /**
   * Load LinkedIn Executive Signals - B2B hiring/leadership changes
   * Uses LinkedIn Alternative service (Perplexity + Serper combo)
   */
  private async loadLinkedInExecutiveSignals(brand: any): Promise<void> {
    const type: ApiEventType = 'linkedin-executive-signals';
    this.updateStatus(type, 'loading');

    try {
      const { linkedInAlternativeService, needsLinkedInData } = await import('./linkedin-alternative.service');

      // Skip if this industry doesn't need LinkedIn data
      if (!needsLinkedInData(brand.industry)) {
        console.log(`[StreamingAPI] ‚è≠Ô∏è Skipping LinkedIn signals - not needed for ${brand.industry}`);
        this.updateStatus(type, 'success');
        return;
      }

      // Get competitors from brand data (passed from context)
      const competitors: string[] = brand.competitors || [];

      const samples: RawDataSample[] = [];

      for (const competitor of competitors.slice(0, 3)) {
        try {
          const insights = await linkedInAlternativeService.getInsights(competitor, brand.industry);

          // Convert buyer intent signals to trigger samples
          insights.buyer_intent_signals.forEach((signal, idx) => {
            samples.push({
              id: `linkedin-intent-${competitor}-${idx}`,
              content: signal.signal,
              source: 'LinkedIn',
              platform: 'LinkedIn',
              sourceType: 'executive',
              competitorName: competitor,
              engagement: Math.round(signal.strength * 100)
            });
          });

          // Convert professional pain points
          insights.professional_pain_points.forEach((pp, idx) => {
            samples.push({
              id: `linkedin-pain-${competitor}-${idx}`,
              content: pp.text,
              source: 'LinkedIn',
              platform: 'LinkedIn',
              sourceType: 'executive',
              competitorName: competitor,
              engagement: Math.round(pp.intensity * 100)
            });
          });
        } catch (err) {
          console.warn(`[StreamingAPI] LinkedIn signals for ${competitor} failed:`, err);
        }
      }

      // Add to raw data buffer (capped at 25)
      const cappedSamples = samples.slice(0, 25);
      if (cappedSamples.length > 0) {
        this.rawDataBuffer.push(...cappedSamples);
        console.log(`[StreamingAPI] üîµ Buffered ${cappedSamples.length} LinkedIn executive samples (total: ${this.rawDataBuffer.length})`);
      }

      this.emitUpdate(type, { linkedInSignals: cappedSamples }, false);
      this.updateStatus(type, 'success');

    } catch (error) {
      console.error('[StreamingAPI] LinkedIn Executive Signals failed:', error);
      this.updateStatus(type, 'error');
    }
  }

  private async saveToCacheasync(brandId: string): Promise<void> {
    // Collect all successful API data
    const allData: any = {};

    // Build DeepContext-like structure from individual API results
    // This runs after all APIs complete, just for caching

    const cacheKey = `deep-context-${brandId}`;
    this.cache.set(cacheKey, {
      data: allData,
      timestamp: Date.now()
    });

    console.log('[StreamingAPI] Saved combined data to cache');
  }

  /**
   * Load competitor Voice of Customer data from brand_competitor_voice table
   * This is HIGH VALUE data - contains pain_points, desires, objections, switching_triggers
   * extracted from competitor reviews and discussions.
   */
  private async loadCompetitorVoiceData(brandId: string): Promise<void> {
    const type: ApiEventType = 'competitor-voice';
    this.updateStatus(type, 'loading');

    try {
      console.log('[StreamingAPI] Loading competitor voice data for brand:', brandId);

      const { supabase } = await import('@/lib/supabase');

      // Load all competitor voice data for this brand
      const { data: voiceData, error } = await supabase
        .from('brand_competitor_voice')
        .select('*')
        .eq('brand_id', brandId);

      if (error) {
        // Table might not exist - gracefully skip
        if (error.code === '42P01' || error.code === 'PGRST205' || error.message?.includes('relation')) {
          console.log('[StreamingAPI] brand_competitor_voice table not found - skipping');
          this.updateStatus(type, 'success');
          return;
        }
        throw error;
      }

      if (!voiceData || voiceData.length === 0) {
        console.log('[StreamingAPI] No competitor voice data found for brand');
        this.updateStatus(type, 'success');
        return;
      }

      console.log(`[StreamingAPI] Found ${voiceData.length} competitor voice records`);

      // Helper: Generate fallback URL for competitor (G2 search)
      const getFallbackUrl = (competitorName: string): string => {
        const slug = competitorName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
        return `https://www.g2.com/search?query=${encodeURIComponent(competitorName)}`;
      };

      // Convert VoC data to trigger-compatible format
      const insights: Array<{
        insight: string;
        sources: Array<{ title: string; url: string; excerpt: string }>;
        category: string;
        competitorName: string;
      }> = [];

      for (const voice of voiceData) {
        const competitorName = voice.competitor_name || 'Competitor';
        const sourceQuotes = voice.source_quotes || [];
        const fallbackUrl = getFallbackUrl(competitorName);

        // Pain points ‚Üí pain-point triggers
        for (const painPoint of (voice.pain_points || [])) {
          const matchingQuote = sourceQuotes.find((sq: any) =>
            painPoint.toLowerCase().includes(sq.quote?.toLowerCase()?.slice(0, 30) || '')
          );
          insights.push({
            insight: painPoint,
            sources: matchingQuote ? [{
              title: matchingQuote.source || `${competitorName} Review`,
              url: matchingQuote.url || fallbackUrl,
              excerpt: matchingQuote.quote || ''
            }] : [{
              title: `${competitorName} Reviews on G2`,
              url: fallbackUrl,
              excerpt: ''
            }],
            category: 'pain-point',
            competitorName
          });
        }

        // Desires ‚Üí desire triggers
        for (const desire of (voice.desires || [])) {
          const matchingQuote = sourceQuotes.find((sq: any) =>
            desire.toLowerCase().includes(sq.quote?.toLowerCase()?.slice(0, 30) || '')
          );
          insights.push({
            insight: desire,
            sources: matchingQuote ? [{
              title: matchingQuote.source || `${competitorName} Review`,
              url: matchingQuote.url || fallbackUrl,
              excerpt: matchingQuote.quote || ''
            }] : [{
              title: `${competitorName} Reviews on G2`,
              url: fallbackUrl,
              excerpt: ''
            }],
            category: 'desire',
            competitorName
          });
        }

        // Objections ‚Üí objection triggers
        for (const objection of (voice.objections || [])) {
          const matchingQuote = sourceQuotes.find((sq: any) =>
            objection.toLowerCase().includes(sq.quote?.toLowerCase()?.slice(0, 30) || '')
          );
          insights.push({
            insight: objection,
            sources: matchingQuote ? [{
              title: matchingQuote.source || `${competitorName} Review`,
              url: matchingQuote.url || fallbackUrl,
              excerpt: matchingQuote.quote || ''
            }] : [{
              title: `${competitorName} Reviews on G2`,
              url: fallbackUrl,
              excerpt: ''
            }],
            category: 'objection',
            competitorName
          });
        }

        // Switching triggers ‚Üí fear/urgency triggers (GOLD MINE!)
        for (const switchTrigger of (voice.switching_triggers || [])) {
          const matchingQuote = sourceQuotes.find((sq: any) =>
            switchTrigger.toLowerCase().includes(sq.quote?.toLowerCase()?.slice(0, 30) || '')
          );
          insights.push({
            insight: switchTrigger,
            sources: matchingQuote ? [{
              title: matchingQuote.source || `${competitorName} Review`,
              url: matchingQuote.url || fallbackUrl,
              excerpt: matchingQuote.quote || ''
            }] : [{
              title: `${competitorName} Reviews on G2`,
              url: fallbackUrl,
              excerpt: ''
            }],
            category: 'fear',  // Switching triggers are often driven by fear
            competitorName
          });
        }

        // Also add source quotes directly as high-value evidence
        for (const sq of sourceQuotes) {
          if (sq.quote && sq.quote.length > 20) {
            insights.push({
              insight: sq.quote,
              sources: [{
                title: sq.source || `${competitorName} Review`,
                url: sq.url || fallbackUrl,
                excerpt: sq.quote
              }],
              category: sq.sentiment === 'negative' ? 'pain-point' : 'desire',
              competitorName
            });
          }
        }
      }

      console.log(`[StreamingAPI] Converted ${insights.length} VoC items to insights`);

      // Filter out positive reviews - they're NOT triggers (happy customers don't switch)
      const POSITIVE_INDICATORS = [
        'really good', 'great experience', 'love it', 'excellent', 'amazing',
        'highly recommend', 'very happy', 'works great', 'very satisfied',
        'best tool', 'perfect for', 'saved a lot of time', 'really helped',
        'fantastic', 'wonderful', 'impressive', 'couldn\'t be happier'
      ];

      const filteredInsights = insights.filter(item => {
        const text = item.insight.toLowerCase();
        // Keep pain-points, objections, fears - these are real triggers
        if (['pain-point', 'objection', 'fear'].includes(item.category)) {
          return true;
        }
        // For desires, filter out ones that are actually satisfied (positive reviews)
        const isPositive = POSITIVE_INDICATORS.some(indicator => text.includes(indicator));
        if (isPositive) {
          console.log(`[StreamingAPI] Filtering positive review (not a trigger): "${item.insight.slice(0, 50)}..."`);
          return false;
        }
        return true;
      });

      console.log(`[StreamingAPI] After filtering positive reviews: ${filteredInsights.length} insights (filtered ${insights.length - filteredInsights.length} positive reviews)`);

      // Emit as Perplexity-like format so useStreamingTriggers can process it
      // Note: Don't prefix with competitor name - the trigger stands on its own
      this.emitUpdate(type, {
        insightsWithSources: filteredInsights.map(item => ({
          insight: item.insight,
          sources: item.sources,
          category: item.category
        })),
        confidence: 0.9,  // VoC data is high quality
        source: 'competitor-voice'
      }, false);

      // Also buffer for LLM synthesis (only filtered insights - no positive reviews)
      for (const item of filteredInsights) {
        this.bufferRawData(type, {
          content: item.insight,
          source: item.sources[0]?.title || 'Competitor Review',
          url: item.sources[0]?.url || '',
          platform: 'competitor-reviews',
          category: item.category
        });
      }

      this.updateStatus(type, 'success');
      console.log('[StreamingAPI] Competitor voice data loaded successfully');

    } catch (error) {
      console.error('[StreamingAPI] Error loading competitor voice data:', error);
      this.handleApiError(type, error instanceof Error ? error : new Error(String(error)));
    }
  }

  // =========================================================================
  // SYNAPSE 2.0: Hidden Data Sources
  // SEC EDGAR + BuzzSumo for unique competitive intelligence
  // =========================================================================

  /**
   * Load SEC EDGAR data for industry intelligence
   * Mines risk factors, executive priorities from 10-K filings
   */
  private async loadSECEdgarIntelligence(brand: any): Promise<void> {
    const type: ApiEventType = 'sec-edgar-intelligence';
    this.updateStatus(type, 'loading');

    try {
      const { secEdgarAPI } = await import('./sec-edgar-api');

      // Extract industry from brand
      const industry = this.currentIndustry || brand.industry || 'technology';

      console.log(`[StreamingAPI] Loading SEC EDGAR intelligence for industry: ${industry}`);

      // Mine industry intelligence
      const result = await secEdgarAPI.mineIndustryIntelligence({
        industry,
        keywords: [brand.name, 'AI', 'automation', 'digital transformation'].filter(Boolean),
        limit: 10
      });

      if (result.insights.length > 0) {
        // Convert to format compatible with insight synthesizer
        const edgarInsights = result.insights.map(insight => ({
          insight: insight.text,
          sources: [{
            title: `${insight.source.company} ${insight.source.formType}`,
            url: insight.source.fileUrl,
            excerpt: insight.text.substring(0, 200)
          }],
          category: insight.type,
          relevance: insight.relevanceScore
        }));

        this.emitUpdate(type, {
          insights: edgarInsights,
          companies: result.companies,
          filingCount: result.filingCount,
          source: 'sec-edgar'
        }, false);

        // Buffer for LLM synthesis
        for (const insight of result.insights) {
          this.bufferRawData(type, {
            content: insight.text,
            source: `SEC ${insight.source.formType}`,
            url: insight.source.fileUrl,
            platform: 'sec-edgar',
            category: insight.type
          });
        }

        console.log(`[StreamingAPI] SEC EDGAR loaded ${result.insights.length} insights from ${result.filingCount} filings`);
      } else {
        console.log('[StreamingAPI] SEC EDGAR: No relevant filings found');
      }

      this.updateStatus(type, 'success');
    } catch (error) {
      console.error('[StreamingAPI] SEC EDGAR error:', error);
      this.handleApiError(type, error instanceof Error ? error : new Error(String(error)));
    }
  }

  /**
   * Load BuzzSumo performance data
   * Content performance + trend timing intelligence
   */
  private async loadBuzzSumoPerformance(brand: any): Promise<void> {
    const type: ApiEventType = 'buzzsumo-performance';
    this.updateStatus(type, 'loading');

    try {
      const { buzzsumoAPI } = await import('./buzzsumo-api');

      const industry = this.currentIndustry || brand.industry || 'technology';
      const brandName = brand.name || '';

      console.log(`[StreamingAPI] Loading BuzzSumo performance data for: ${industry}`);

      // Get what's working now
      const whatsWorking = await buzzsumoAPI.getWhatsWorkingNow(industry, brandName);

      if (whatsWorking) {
        // Extract headline patterns
        const headlinePatterns = buzzsumoAPI.extractHeadlinePatterns(
          whatsWorking.topContent.map(c => c.title)
        );

        // Calculate trend timing
        const trendTiming = this.calculateTrendTiming(whatsWorking);

        this.emitUpdate(type, {
          topContent: whatsWorking.topContent.slice(0, 10),
          trendingTopics: whatsWorking.trendingTopics.slice(0, 5),
          headlinePatterns,
          trendTiming,
          engagementBenchmarks: {
            avgShares: whatsWorking.topContent.reduce((sum, c) => sum + c.totalShares, 0) / whatsWorking.topContent.length,
            avgEngagement: whatsWorking.topContent.reduce((sum, c) => sum + c.engagement, 0) / whatsWorking.topContent.length
          },
          source: 'buzzsumo'
        }, false);

        // Buffer top content for LLM synthesis
        for (const content of whatsWorking.topContent.slice(0, 5)) {
          this.bufferRawData(type, {
            content: `High-performing content: "${content.title}" - ${content.totalShares} shares`,
            source: content.domain || 'BuzzSumo',
            url: content.url,
            platform: 'buzzsumo',
            category: 'content-performance'
          });
        }

        console.log(`[StreamingAPI] BuzzSumo loaded ${whatsWorking.topContent.length} top content items`);
      }

      this.updateStatus(type, 'success');
    } catch (error) {
      console.error('[StreamingAPI] BuzzSumo error:', error);
      this.handleApiError(type, error instanceof Error ? error : new Error(String(error)));
    }
  }

  /**
   * Calculate trend timing from BuzzSumo data
   * Identifies where in the lifecycle a topic is (early/peak/saturated)
   */
  private calculateTrendTiming(data: any): {
    lifecycle: 'emerging' | 'growing' | 'peak' | 'saturated';
    recommendation: string;
    confidence: number;
  } {
    // Simple heuristic based on content age and engagement
    const contentAges = data.topContent.map((c: any) => {
      const published = new Date(c.publishedDate);
      const now = new Date();
      return (now.getTime() - published.getTime()) / (1000 * 60 * 60 * 24); // days
    });

    const avgAge = contentAges.reduce((a: number, b: number) => a + b, 0) / contentAges.length;
    const recentCount = contentAges.filter((age: number) => age < 7).length;
    const recentRatio = recentCount / contentAges.length;

    // Determine lifecycle stage
    let lifecycle: 'emerging' | 'growing' | 'peak' | 'saturated';
    let recommendation: string;
    let confidence: number;

    if (recentRatio > 0.7 && avgAge < 5) {
      lifecycle = 'emerging';
      recommendation = 'Perfect timing - publish now to establish authority before competition floods in';
      confidence = 0.85;
    } else if (recentRatio > 0.4 && avgAge < 14) {
      lifecycle = 'growing';
      recommendation = 'Good timing - still room to capture attention with quality content';
      confidence = 0.75;
    } else if (recentRatio > 0.2 && avgAge < 30) {
      lifecycle = 'peak';
      recommendation = 'High competition - need unique angle or deeper insights to stand out';
      confidence = 0.7;
    } else {
      lifecycle = 'saturated';
      recommendation = 'Saturated topic - consider adjacent angles or wait for next wave';
      confidence = 0.65;
    }

    return { lifecycle, recommendation, confidence };
  }

  /**
   * Get current status of all APIs
   */
  getApiStatuses(): Map<ApiEventType, ApiStatus> {
    return this.apiStatuses;
  }

  /**
   * Clear all listeners and reset state
   */
  reset(): void {
    // Clear batch state
    if (this.batchFlushTimeout) {
      clearTimeout(this.batchFlushTimeout);
      this.batchFlushTimeout = null;
    }
    this.eventBuffer.clear();

    this.removeAllListeners();
    this.apiStatuses.clear();
  }
}

// Export singleton instance
export const streamingApiManager = new StreamingApiManager();